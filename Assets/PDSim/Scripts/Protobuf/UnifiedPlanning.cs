// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: unified_planning.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
/// <summary>Holder for reflection information generated from unified_planning.proto</summary>
public static partial class UnifiedPlanningReflection
{

  #region Descriptor
  /// <summary>File descriptor for unified_planning.proto</summary>
  public static pbr::FileDescriptor Descriptor
  {
    get { return descriptor; }
  }
  private static pbr::FileDescriptor descriptor;

  static UnifiedPlanningReflection()
  {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        string.Concat(
          "ChZ1bmlmaWVkX3BsYW5uaW5nLnByb3RvImkKCkV4cHJlc3Npb24SEwoEYXRv",
          "bRgBIAEoCzIFLkF0b20SGQoEbGlzdBgCIAMoCzILLkV4cHJlc3Npb24SDAoE",
          "dHlwZRgDIAEoCRIdCgRraW5kGAQgASgOMg8uRXhwcmVzc2lvbktpbmQiXAoE",
          "QXRvbRIQCgZzeW1ib2wYASABKAlIABINCgNpbnQYAiABKANIABIVCgRyZWFs",
          "GAMgASgLMgUuUmVhbEgAEhEKB2Jvb2xlYW4YBCABKAhIAEIJCgdjb250ZW50",
          "Ii4KBFJlYWwSEQoJbnVtZXJhdG9yGAEgASgDEhMKC2Rlbm9taW5hdG9yGAIg",
          "ASgDIjkKD1R5cGVEZWNsYXJhdGlvbhIRCgl0eXBlX25hbWUYASABKAkSEwoL",
          "cGFyZW50X3R5cGUYAiABKAkiJwoJUGFyYW1ldGVyEgwKBG5hbWUYASABKAkS",
          "DAoEdHlwZRgCIAEoCSJuCgZGbHVlbnQSDAoEbmFtZRgBIAEoCRISCgp2YWx1",
          "ZV90eXBlGAIgASgJEh4KCnBhcmFtZXRlcnMYAyADKAsyCi5QYXJhbWV0ZXIS",
          "IgoNZGVmYXVsdF92YWx1ZRgEIAEoCzILLkV4cHJlc3Npb24iLwoRT2JqZWN0",
          "RGVjbGFyYXRpb24SDAoEbmFtZRgBIAEoCRIMCgR0eXBlGAIgASgJIuoBChBF",
          "ZmZlY3RFeHByZXNzaW9uEioKBGtpbmQYASABKA4yHC5FZmZlY3RFeHByZXNz",
          "aW9uLkVmZmVjdEtpbmQSGwoGZmx1ZW50GAIgASgLMgsuRXhwcmVzc2lvbhIa",
          "CgV2YWx1ZRgDIAEoCzILLkV4cHJlc3Npb24SHgoJY29uZGl0aW9uGAQgASgL",
          "MgsuRXhwcmVzc2lvbhIbCgZmb3JhbGwYBSADKAsyCy5FeHByZXNzaW9uIjQK",
          "CkVmZmVjdEtpbmQSCgoGQVNTSUdOEAASDAoISU5DUkVBU0UQARIMCghERUNS",
          "RUFTRRACIk0KBkVmZmVjdBIhCgZlZmZlY3QYASABKAsyES5FZmZlY3RFeHBy",
          "ZXNzaW9uEiAKD29jY3VycmVuY2VfdGltZRgCIAEoCzIHLlRpbWluZyJDCglD",
          "b25kaXRpb24SGQoEY29uZBgBIAEoCzILLkV4cHJlc3Npb24SGwoEc3BhbhgC",
          "IAEoCzINLlRpbWVJbnRlcnZhbCKNAQoGQWN0aW9uEgwKBG5hbWUYASABKAkS",
          "HgoKcGFyYW1ldGVycxgCIAMoCzIKLlBhcmFtZXRlchIbCghkdXJhdGlvbhgD",
          "IAEoCzIJLkR1cmF0aW9uEh4KCmNvbmRpdGlvbnMYBCADKAsyCi5Db25kaXRp",
          "b24SGAoHZWZmZWN0cxgFIAMoCzIHLkVmZmVjdCKQAQoJVGltZXBvaW50EiYK",
          "BGtpbmQYASABKA4yGC5UaW1lcG9pbnQuVGltZXBvaW50S2luZBIUCgxjb250",
          "YWluZXJfaWQYAiABKAkiRQoNVGltZXBvaW50S2luZBIQCgxHTE9CQUxfU1RB",
          "UlQQABIOCgpHTE9CQUxfRU5EEAESCQoFU1RBUlQQAhIHCgNFTkQQAyI9CgZU",
          "aW1pbmcSHQoJdGltZXBvaW50GAEgASgLMgouVGltZXBvaW50EhQKBWRlbGF5",
          "GAIgASgLMgUuUmVhbCJvCghJbnRlcnZhbBIUCgxpc19sZWZ0X29wZW4YASAB",
          "KAgSGgoFbG93ZXIYAiABKAsyCy5FeHByZXNzaW9uEhUKDWlzX3JpZ2h0X29w",
          "ZW4YAyABKAgSGgoFdXBwZXIYBCABKAsyCy5FeHByZXNzaW9uImsKDFRpbWVJ",
          "bnRlcnZhbBIUCgxpc19sZWZ0X29wZW4YASABKAgSFgoFbG93ZXIYAiABKAsy",
          "By5UaW1pbmcSFQoNaXNfcmlnaHRfb3BlbhgDIAEoCBIWCgV1cHBlchgEIAEo",
          "CzIHLlRpbWluZyI1CghEdXJhdGlvbhIpChZjb250cm9sbGFibGVfaW5fYm91",
          "bmRzGAEgASgLMgkuSW50ZXJ2YWwiRwoXQWJzdHJhY3RUYXNrRGVjbGFyYXRp",
          "b24SDAoEbmFtZRgBIAEoCRIeCgpwYXJhbWV0ZXJzGAIgAygLMgouUGFyYW1l",
          "dGVyIkYKBFRhc2sSCgoCaWQYASABKAkSEQoJdGFza19uYW1lGAIgASgJEh8K",
          "CnBhcmFtZXRlcnMYAyADKAsyCy5FeHByZXNzaW9uIq8BCgZNZXRob2QSDAoE",
          "bmFtZRgBIAEoCRIeCgpwYXJhbWV0ZXJzGAIgAygLMgouUGFyYW1ldGVyEhwK",
          "DWFjaGlldmVkX3Rhc2sYAyABKAsyBS5UYXNrEhcKCHN1YnRhc2tzGAQgAygL",
          "MgUuVGFzaxIgCgtjb25zdHJhaW50cxgFIAMoCzILLkV4cHJlc3Npb24SHgoK",
          "Y29uZGl0aW9ucxgGIAMoCzIKLkNvbmRpdGlvbiJnCgtUYXNrTmV0d29yaxId",
          "Cgl2YXJpYWJsZXMYASADKAsyCi5QYXJhbWV0ZXISFwoIc3VidGFza3MYAiAD",
          "KAsyBS5UYXNrEiAKC2NvbnN0cmFpbnRzGAMgAygLMgsuRXhwcmVzc2lvbiKD",
          "AQoJSGllcmFyY2h5EjAKDmFic3RyYWN0X3Rhc2tzGAEgAygLMhguQWJzdHJh",
          "Y3RUYXNrRGVjbGFyYXRpb24SGAoHbWV0aG9kcxgCIAMoCzIHLk1ldGhvZBIq",
          "ChRpbml0aWFsX3Rhc2tfbmV0d29yaxgDIAEoCzIMLlRhc2tOZXR3b3JrIrEB",
          "CghBY3Rpdml0eRIMCgRuYW1lGAEgASgJEh4KCnBhcmFtZXRlcnMYAiADKAsy",
          "Ci5QYXJhbWV0ZXISGwoIZHVyYXRpb24YAyABKAsyCS5EdXJhdGlvbhIeCgpj",
          "b25kaXRpb25zGAQgAygLMgouQ29uZGl0aW9uEhgKB2VmZmVjdHMYBSADKAsy",
          "By5FZmZlY3QSIAoLY29uc3RyYWludHMYBiADKAsyCy5FeHByZXNzaW9uInUK",
          "E1NjaGVkdWxpbmdFeHRlbnNpb24SHQoKYWN0aXZpdGllcxgBIAMoCzIJLkFj",
          "dGl2aXR5Eh0KCXZhcmlhYmxlcxgCIAMoCzIKLlBhcmFtZXRlchIgCgtjb25z",
          "dHJhaW50cxgFIAMoCzILLkV4cHJlc3Npb24iowEKCFNjaGVkdWxlEhIKCmFj",
          "dGl2aXRpZXMYASADKAkSQAoUdmFyaWFibGVfYXNzaWdubWVudHMYAiADKAsy",
          "Ii5TY2hlZHVsZS5WYXJpYWJsZUFzc2lnbm1lbnRzRW50cnkaQQoYVmFyaWFi",
          "bGVBc3NpZ25tZW50c0VudHJ5EgsKA2tleRgBIAEoCRIUCgV2YWx1ZRgCIAEo",
          "CzIFLkF0b206AjgBIkAKBEdvYWwSGQoEZ29hbBgBIAEoCzILLkV4cHJlc3Np",
          "b24SHQoGdGltaW5nGAIgASgLMg0uVGltZUludGVydmFsIlIKC1RpbWVkRWZm",
          "ZWN0EiEKBmVmZmVjdBgBIAEoCzIRLkVmZmVjdEV4cHJlc3Npb24SIAoPb2Nj",
          "dXJyZW5jZV90aW1lGAIgASgLMgcuVGltaW5nIkUKCkFzc2lnbm1lbnQSGwoG",
          "Zmx1ZW50GAEgASgLMgsuRXhwcmVzc2lvbhIaCgV2YWx1ZRgCIAEoCzILLkV4",
          "cHJlc3Npb24iQgoOR29hbFdpdGhXZWlnaHQSGQoEZ29hbBgBIAEoCzILLkV4",
          "cHJlc3Npb24SFQoGd2VpZ2h0GAIgASgLMgUuUmVhbCJmChNUaW1lZEdvYWxX",
          "aXRoV2VpZ2h0EhkKBGdvYWwYASABKAsyCy5FeHByZXNzaW9uEh0KBnRpbWlu",
          "ZxgCIAEoCzINLlRpbWVJbnRlcnZhbBIVCgZ3ZWlnaHQYAyABKAsyBS5SZWFs",
          "IpwECgZNZXRyaWMSIAoEa2luZBgBIAEoDjISLk1ldHJpYy5NZXRyaWNLaW5k",
          "Eh8KCmV4cHJlc3Npb24YAiABKAsyCy5FeHByZXNzaW9uEi4KDGFjdGlvbl9j",
          "b3N0cxgDIAMoCzIYLk1ldHJpYy5BY3Rpb25Db3N0c0VudHJ5EigKE2RlZmF1",
          "bHRfYWN0aW9uX2Nvc3QYBCABKAsyCy5FeHByZXNzaW9uEh4KBWdvYWxzGAUg",
          "AygLMg8uR29hbFdpdGhXZWlnaHQSKQoLdGltZWRfZ29hbHMYBiADKAsyFC5U",
          "aW1lZEdvYWxXaXRoV2VpZ2h0Gj8KEEFjdGlvbkNvc3RzRW50cnkSCwoDa2V5",
          "GAEgASgJEhoKBXZhbHVlGAIgASgLMgsuRXhwcmVzc2lvbjoCOAEi6AEKCk1l",
          "dHJpY0tpbmQSGQoVTUlOSU1JWkVfQUNUSU9OX0NPU1RTEAASIwofTUlOSU1J",
          "WkVfU0VRVUVOVElBTF9QTEFOX0xFTkdUSBABEhUKEU1JTklNSVpFX01BS0VT",
          "UEFOEAISJgoiTUlOSU1JWkVfRVhQUkVTU0lPTl9PTl9GSU5BTF9TVEFURRAD",
          "EiYKIk1BWElNSVpFX0VYUFJFU1NJT05fT05fRklOQUxfU1RBVEUQBBIUChBP",
          "VkVSU1VCU0NSSVBUSU9OEAUSHQoZVEVNUE9SQUxfT1ZFUlNVQlNDUklQVElP",
          "ThAGIowECgdQcm9ibGVtEhMKC2RvbWFpbl9uYW1lGAEgASgJEhQKDHByb2Js",
          "ZW1fbmFtZRgCIAEoCRIfCgV0eXBlcxgDIAMoCzIQLlR5cGVEZWNsYXJhdGlv",
          "bhIYCgdmbHVlbnRzGAQgAygLMgcuRmx1ZW50EiMKB29iamVjdHMYBSADKAsy",
          "Ei5PYmplY3REZWNsYXJhdGlvbhIYCgdhY3Rpb25zGAYgAygLMgcuQWN0aW9u",
          "EiIKDWluaXRpYWxfc3RhdGUYByADKAsyCy5Bc3NpZ25tZW50EiMKDXRpbWVk",
          "X2VmZmVjdHMYCCADKAsyDC5UaW1lZEVmZmVjdBIUCgVnb2FscxgJIAMoCzIF",
          "LkdvYWwSGgoIZmVhdHVyZXMYCiADKA4yCC5GZWF0dXJlEhgKB21ldHJpY3MY",
          "CyADKAsyBy5NZXRyaWMSHQoJaGllcmFyY2h5GAwgASgLMgouSGllcmFyY2h5",
          "EjIKFHNjaGVkdWxpbmdfZXh0ZW5zaW9uGBEgASgLMhQuU2NoZWR1bGluZ0V4",
          "dGVuc2lvbhIrChZ0cmFqZWN0b3J5X2NvbnN0cmFpbnRzGA0gAygLMgsuRXhw",
          "cmVzc2lvbhIVCg1kaXNjcmV0ZV90aW1lGA4gASgIEhgKEHNlbGZfb3Zlcmxh",
          "cHBpbmcYDyABKAgSFgoHZXBzaWxvbhgQIAEoCzIFLlJlYWwigAEKDkFjdGlv",
          "bkluc3RhbmNlEgoKAmlkGAEgASgJEhMKC2FjdGlvbl9uYW1lGAIgASgJEhkK",
          "CnBhcmFtZXRlcnMYAyADKAsyBS5BdG9tEhkKCnN0YXJ0X3RpbWUYBCABKAsy",
          "BS5SZWFsEhcKCGVuZF90aW1lGAUgASgLMgUuUmVhbCKuAQoOTWV0aG9kSW5z",
          "dGFuY2USCgoCaWQYASABKAkSEwoLbWV0aG9kX25hbWUYAiABKAkSGQoKcGFy",
          "YW1ldGVycxgDIAMoCzIFLkF0b20SLwoIc3VidGFza3MYBiADKAsyHS5NZXRo",
          "b2RJbnN0YW5jZS5TdWJ0YXNrc0VudHJ5Gi8KDVN1YnRhc2tzRW50cnkSCwoD",
          "a2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ASKWAQoNUGxhbkhpZXJhcmNo",
          "eRIxCgpyb290X3Rhc2tzGAEgAygLMh0uUGxhbkhpZXJhcmNoeS5Sb290VGFz",
          "a3NFbnRyeRIgCgdtZXRob2RzGAIgAygLMg8uTWV0aG9kSW5zdGFuY2UaMAoO",
          "Um9vdFRhc2tzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4",
          "ASJoCgRQbGFuEiAKB2FjdGlvbnMYASADKAsyDy5BY3Rpb25JbnN0YW5jZRIh",
          "CgloaWVyYXJjaHkYAiABKAsyDi5QbGFuSGllcmFyY2h5EhsKCHNjaGVkdWxl",
          "GAMgASgLMgkuU2NoZWR1bGUigwIKC1BsYW5SZXF1ZXN0EhkKB3Byb2JsZW0Y",
          "ASABKAsyCC5Qcm9ibGVtEioKD3Jlc29sdXRpb25fbW9kZRgCIAEoDjIRLlBs",
          "YW5SZXF1ZXN0Lk1vZGUSDwoHdGltZW91dBgDIAEoARI3Cg5lbmdpbmVfb3B0",
          "aW9ucxgEIAMoCzIfLlBsYW5SZXF1ZXN0LkVuZ2luZU9wdGlvbnNFbnRyeRo0",
          "ChJFbmdpbmVPcHRpb25zRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIg",
          "ASgJOgI4ASItCgRNb2RlEg8KC1NBVElTRklBQkxFEAASFAoQU09MVkVEX09Q",
          "VElNQUxMWRABIkMKEVZhbGlkYXRpb25SZXF1ZXN0EhkKB3Byb2JsZW0YASAB",
          "KAsyCC5Qcm9ibGVtEhMKBHBsYW4YAiABKAsyBS5QbGFuInsKCkxvZ01lc3Nh",
          "Z2USIwoFbGV2ZWwYASABKA4yFC5Mb2dNZXNzYWdlLkxvZ0xldmVsEg8KB21l",
          "c3NhZ2UYAiABKAkiNwoITG9nTGV2ZWwSCQoFREVCVUcQABIICgRJTkZPEAES",
          "CwoHV0FSTklORxACEgkKBUVSUk9SEAMivwMKFFBsYW5HZW5lcmF0aW9uUmVz",
          "dWx0EiwKBnN0YXR1cxgBIAEoDjIcLlBsYW5HZW5lcmF0aW9uUmVzdWx0LlN0",
          "YXR1cxITCgRwbGFuGAIgASgLMgUuUGxhbhIzCgdtZXRyaWNzGAMgAygLMiIu",
          "UGxhbkdlbmVyYXRpb25SZXN1bHQuTWV0cmljc0VudHJ5EiEKDGxvZ19tZXNz",
          "YWdlcxgEIAMoCzILLkxvZ01lc3NhZ2USFwoGZW5naW5lGAUgASgLMgcuRW5n",
          "aW5lGi4KDE1ldHJpY3NFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiAB",
          "KAk6AjgBIsIBCgZTdGF0dXMSFgoSU09MVkVEX1NBVElTRklDSU5HEAASFAoQ",
          "U09MVkVEX09QVElNQUxMWRABEhUKEVVOU09MVkFCTEVfUFJPVkVOEAISGwoX",
          "VU5TT0xWQUJMRV9JTkNPTVBMRVRFTFkQAxILCgdUSU1FT1VUEA0SCgoGTUVN",
          "T1VUEA4SEgoOSU5URVJOQUxfRVJST1IQDxIXChNVTlNVUFBPUlRFRF9QUk9C",
          "TEVNEBASEAoMSU5URVJNRURJQVRFEBEiFgoGRW5naW5lEgwKBG5hbWUYASAB",
          "KAkixwEKEFZhbGlkYXRpb25SZXN1bHQSOAoGc3RhdHVzGAEgASgOMiguVmFs",
          "aWRhdGlvblJlc3VsdC5WYWxpZGF0aW9uUmVzdWx0U3RhdHVzEiEKDGxvZ19t",
          "ZXNzYWdlcxgCIAMoCzILLkxvZ01lc3NhZ2USFwoGZW5naW5lGAMgASgLMgcu",
          "RW5naW5lIj0KFlZhbGlkYXRpb25SZXN1bHRTdGF0dXMSCQoFVkFMSUQQABIL",
          "CgdJTlZBTElEEAESCwoHVU5LTk9XThACIuUBCg5Db21waWxlclJlc3VsdBIZ",
          "Cgdwcm9ibGVtGAEgASgLMgguUHJvYmxlbRI3Cg1tYXBfYmFja19wbGFuGAIg",
          "AygLMiAuQ29tcGlsZXJSZXN1bHQuTWFwQmFja1BsYW5FbnRyeRIhCgxsb2df",
          "bWVzc2FnZXMYAyADKAsyCy5Mb2dNZXNzYWdlEhcKBmVuZ2luZRgEIAEoCzIH",
          "LkVuZ2luZRpDChBNYXBCYWNrUGxhbkVudHJ5EgsKA2tleRgBIAEoCRIeCgV2",
          "YWx1ZRgCIAEoCzIPLkFjdGlvbkluc3RhbmNlOgI4ASqwAQoORXhwcmVzc2lv",
          "bktpbmQSCwoHVU5LTk9XThAAEgwKCENPTlNUQU5UEAESDQoJUEFSQU1FVEVS",
          "EAISDAoIVkFSSUFCTEUQBxIRCg1GTFVFTlRfU1lNQk9MEAMSEwoPRlVOQ1RJ",
          "T05fU1lNQk9MEAQSEgoOU1RBVEVfVkFSSUFCTEUQBRIYChRGVU5DVElPTl9B",
          "UFBMSUNBVElPThAGEhAKDENPTlRBSU5FUl9JRBAIKrQMCgdGZWF0dXJlEhAK",
          "DEFDVElPTl9CQVNFRBAAEhAKDEhJRVJBUkNISUNBTBAaEg4KClNDSEVEVUxJ",
          "TkcQOBIbChdTSU1QTEVfTlVNRVJJQ19QTEFOTklORxAeEhwKGEdFTkVSQUxf",
          "TlVNRVJJQ19QTEFOTklORxAfEhMKD0NPTlRJTlVPVVNfVElNRRABEhEKDURJ",
          "U0NSRVRFX1RJTUUQAhInCiNJTlRFUk1FRElBVEVfQ09ORElUSU9OU19BTkRf",
          "RUZGRUNUUxADEiMKH0VYVEVSTkFMX0NPTkRJVElPTlNfQU5EX0VGRkVDVFMQ",
          "JxIRCg1USU1FRF9FRkZFQ1RTEAQSDwoLVElNRURfR09BTFMQBRIZChVEVVJB",
          "VElPTl9JTkVRVUFMSVRJRVMQBhIUChBTRUxGX09WRVJMQVBQSU5HEC8SHwob",
          "U1RBVElDX0ZMVUVOVFNfSU5fRFVSQVRJT05TEBsSGAoURkxVRU5UU19JTl9E",
          "VVJBVElPTlMQHBIWChJDT05USU5VT1VTX05VTUJFUlMQBxIUChBESVNDUkVU",
          "RV9OVU1CRVJTEAgSEQoNQk9VTkRFRF9UWVBFUxAmEhcKE05FR0FUSVZFX0NP",
          "TkRJVElPTlMQCRIaChZESVNKVU5DVElWRV9DT05ESVRJT05TEAoSDgoKRVFV",
          "QUxJVElFUxALEhoKFkVYSVNURU5USUFMX0NPTkRJVElPTlMQDBIYChRVTklW",
          "RVJTQUxfQ09ORElUSU9OUxANEhcKE0NPTkRJVElPTkFMX0VGRkVDVFMQDhIU",
          "ChBJTkNSRUFTRV9FRkZFQ1RTEA8SFAoQREVDUkVBU0VfRUZGRUNUUxAQEikK",
          "JVNUQVRJQ19GTFVFTlRTX0lOX0JPT0xFQU5fQVNTSUdOTUVOVFMQKRIpCiVT",
          "VEFUSUNfRkxVRU5UU19JTl9OVU1FUklDX0FTU0lHTk1FTlRTECoSKAokU1RB",
          "VElDX0ZMVUVOVFNfSU5fT0JKRUNUX0FTU0lHTk1FTlRTEDkSIgoeRkxVRU5U",
          "U19JTl9CT09MRUFOX0FTU0lHTk1FTlRTECsSIgoeRkxVRU5UU19JTl9OVU1F",
          "UklDX0FTU0lHTk1FTlRTECwSIQodRkxVRU5UU19JTl9PQkpFQ1RfQVNTSUdO",
          "TUVOVFMQOhISCg5GT1JBTExfRUZGRUNUUxA7Eg8KC0ZMQVRfVFlQSU5HEBES",
          "FwoTSElFUkFSQ0hJQ0FMX1RZUElORxASEhMKD05VTUVSSUNfRkxVRU5UUxAT",
          "EhIKDk9CSkVDVF9GTFVFTlRTEBQSGgoWQk9PTF9GTFVFTlRfUEFSQU1FVEVS",
          "UxAyEiEKHUJPVU5ERURfSU5UX0ZMVUVOVF9QQVJBTUVURVJTEDMSGgoWQk9P",
          "TF9BQ1RJT05fUEFSQU1FVEVSUxA0EiEKHUJPVU5ERURfSU5UX0FDVElPTl9Q",
          "QVJBTUVURVJTEDUSIwofVU5CT1VOREVEX0lOVF9BQ1RJT05fUEFSQU1FVEVS",
          "UxA2EhoKFlJFQUxfQUNUSU9OX1BBUkFNRVRFUlMQNxIQCgxBQ1RJT05TX0NP",
          "U1QQFRIPCgtGSU5BTF9WQUxVRRAWEgwKCE1BS0VTUEFOEBcSDwoLUExBTl9M",
          "RU5HVEgQGBIUChBPVkVSU1VCU0NSSVBUSU9OEB0SHQoZVEVNUE9SQUxfT1ZF",
          "UlNVQlNDUklQVElPThAoEiIKHlNUQVRJQ19GTFVFTlRTX0lOX0FDVElPTlNf",
          "Q09TVBAtEhsKF0ZMVUVOVFNfSU5fQUNUSU9OU19DT1NUEC4SFQoRU0lNVUxB",
          "VEVEX0VGRkVDVFMQGRIaChZUUkFKRUNUT1JZX0NPTlNUUkFJTlRTEDASFAoQ",
          "U1RBVEVfSU5WQVJJQU5UUxAxEhgKFE1FVEhPRF9QUkVDT05ESVRJT05TECAS",
          "HAoYVEFTS19ORVRXT1JLX0NPTlNUUkFJTlRTECESIgoeSU5JVElBTF9UQVNL",
          "X05FVFdPUktfVkFSSUFCTEVTECISFAoQVEFTS19PUkRFUl9UT1RBTBAjEhYK",
          "ElRBU0tfT1JERVJfUEFSVElBTBAkEhcKE1RBU0tfT1JERVJfVEVNUE9SQUwQ",
          "JTLYAQoPVW5pZmllZFBsYW5uaW5nEjQKC3BsYW5Bbnl0aW1lEgwuUGxhblJl",
          "cXVlc3QaFS5QbGFuR2VuZXJhdGlvblJlc3VsdDABEjIKC3BsYW5PbmVTaG90",
          "EgwuUGxhblJlcXVlc3QaFS5QbGFuR2VuZXJhdGlvblJlc3VsdBI1Cgx2YWxp",
          "ZGF0ZVBsYW4SEi5WYWxpZGF0aW9uUmVxdWVzdBoRLlZhbGlkYXRpb25SZXN1",
          "bHQSJAoHY29tcGlsZRIILlByb2JsZW0aDy5Db21waWxlclJlc3VsdGIGcHJv",
          "dG8z"));
    descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
        new pbr::FileDescriptor[] { },
        new pbr::GeneratedClrTypeInfo(new[] { typeof(global::ExpressionKind), typeof(global::Feature), }, new pbr::GeneratedClrTypeInfo[] {
          new pbr::GeneratedClrTypeInfo(typeof(global::Expression), global::Expression.Parser, new[]{ "Atom", "List", "Type", "Kind" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Atom), global::Atom.Parser, new[]{ "Symbol", "Int", "Real", "Boolean" }, new[]{ "Content" }, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Real), global::Real.Parser, new[]{ "Numerator", "Denominator" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::TypeDeclaration), global::TypeDeclaration.Parser, new[]{ "TypeName", "ParentType" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Parameter), global::Parameter.Parser, new[]{ "Name", "Type" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Fluent), global::Fluent.Parser, new[]{ "Name", "ValueType", "Parameters", "DefaultValue" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::ObjectDeclaration), global::ObjectDeclaration.Parser, new[]{ "Name", "Type" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::EffectExpression), global::EffectExpression.Parser, new[]{ "Kind", "Fluent", "Value", "Condition", "Forall" }, null, new[]{ typeof(global::EffectExpression.Types.EffectKind) }, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Effect), global::Effect.Parser, new[]{ "Effect_", "OccurrenceTime" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Condition), global::Condition.Parser, new[]{ "Cond", "Span" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Action), global::Action.Parser, new[]{ "Name", "Parameters", "Duration", "Conditions", "Effects" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Timepoint), global::Timepoint.Parser, new[]{ "Kind", "ContainerId" }, null, new[]{ typeof(global::Timepoint.Types.TimepointKind) }, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Timing), global::Timing.Parser, new[]{ "Timepoint", "Delay" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Interval), global::Interval.Parser, new[]{ "IsLeftOpen", "Lower", "IsRightOpen", "Upper" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::TimeInterval), global::TimeInterval.Parser, new[]{ "IsLeftOpen", "Lower", "IsRightOpen", "Upper" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Duration), global::Duration.Parser, new[]{ "ControllableInBounds" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::AbstractTaskDeclaration), global::AbstractTaskDeclaration.Parser, new[]{ "Name", "Parameters" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Task), global::Task.Parser, new[]{ "Id", "TaskName", "Parameters" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Method), global::Method.Parser, new[]{ "Name", "Parameters", "AchievedTask", "Subtasks", "Constraints", "Conditions" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::TaskNetwork), global::TaskNetwork.Parser, new[]{ "Variables", "Subtasks", "Constraints" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Hierarchy), global::Hierarchy.Parser, new[]{ "AbstractTasks", "Methods", "InitialTaskNetwork" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Activity), global::Activity.Parser, new[]{ "Name", "Parameters", "Duration", "Conditions", "Effects", "Constraints" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::SchedulingExtension), global::SchedulingExtension.Parser, new[]{ "Activities", "Variables", "Constraints" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Schedule), global::Schedule.Parser, new[]{ "Activities", "VariableAssignments" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(global::Goal), global::Goal.Parser, new[]{ "Goal_", "Timing" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::TimedEffect), global::TimedEffect.Parser, new[]{ "Effect", "OccurrenceTime" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Assignment), global::Assignment.Parser, new[]{ "Fluent", "Value" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::GoalWithWeight), global::GoalWithWeight.Parser, new[]{ "Goal", "Weight" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::TimedGoalWithWeight), global::TimedGoalWithWeight.Parser, new[]{ "Goal", "Timing", "Weight" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::Metric), global::Metric.Parser, new[]{ "Kind", "Expression", "ActionCosts", "DefaultActionCost", "Goals", "TimedGoals" }, null, new[]{ typeof(global::Metric.Types.MetricKind) }, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(global::Problem), global::Problem.Parser, new[]{ "DomainName", "ProblemName", "Types_", "Fluents", "Objects", "Actions", "InitialState", "TimedEffects", "Goals", "Features", "Metrics", "Hierarchy", "SchedulingExtension", "TrajectoryConstraints", "DiscreteTime", "SelfOverlapping", "Epsilon" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::ActionInstance), global::ActionInstance.Parser, new[]{ "Id", "ActionName", "Parameters", "StartTime", "EndTime" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::MethodInstance), global::MethodInstance.Parser, new[]{ "Id", "MethodName", "Parameters", "Subtasks" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(global::PlanHierarchy), global::PlanHierarchy.Parser, new[]{ "RootTasks", "Methods" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(global::Plan), global::Plan.Parser, new[]{ "Actions", "Hierarchy", "Schedule" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::PlanRequest), global::PlanRequest.Parser, new[]{ "Problem", "ResolutionMode", "Timeout", "EngineOptions" }, null, new[]{ typeof(global::PlanRequest.Types.Mode) }, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(global::ValidationRequest), global::ValidationRequest.Parser, new[]{ "Problem", "Plan" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::LogMessage), global::LogMessage.Parser, new[]{ "Level", "Message" }, null, new[]{ typeof(global::LogMessage.Types.LogLevel) }, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::PlanGenerationResult), global::PlanGenerationResult.Parser, new[]{ "Status", "Plan", "Metrics", "LogMessages", "Engine" }, null, new[]{ typeof(global::PlanGenerationResult.Types.Status) }, new pbr::GeneratedClrTypeInfo[] { null, }),
          new pbr::GeneratedClrTypeInfo(typeof(global::Engine), global::Engine.Parser, new[]{ "Name" }, null, null, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::ValidationResult), global::ValidationResult.Parser, new[]{ "Status", "LogMessages", "Engine" }, null, new[]{ typeof(global::ValidationResult.Types.ValidationResultStatus) }, null),
          new pbr::GeneratedClrTypeInfo(typeof(global::CompilerResult), global::CompilerResult.Parser, new[]{ "Problem", "MapBackPlan", "LogMessages", "Engine" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, })
        }));
  }
  #endregion

}
#region Enums
/// <summary>
/// The kind of an expression, which gives information related to its structure.
/// </summary>
public enum ExpressionKind
{
  /// <summary>
  /// Default value, should not be used. Drop it if we are sure to never need it.
  /// </summary>
  [pbr::OriginalName("UNKNOWN")] Unknown = 0,
  /// <summary>
  /// Constant atom. For instance `3` or `kitchen` (where `kitchen` is an object defined in the problem)
  /// </summary>
  [pbr::OriginalName("CONSTANT")] Constant = 1,
  /// <summary>
  /// Atom symbol representing a parameter from an outer scope. For instance `from` that would appear inside a `(move from to - location)` action.
  /// </summary>
  [pbr::OriginalName("PARAMETER")] Parameter = 2,
  /// <summary>
  /// Atom symbol representing a variable from an outer scope.
  /// This is typically used to represent the variables that are existentially or universally qualified in expressions.
  /// </summary>
  [pbr::OriginalName("VARIABLE")] Variable = 7,
  /// <summary>
  /// Atom symbol representing a fluent of the problem. For instance `at-robot`.
  /// </summary>
  [pbr::OriginalName("FLUENT_SYMBOL")] FluentSymbol = 3,
  /// <summary>
  /// Atom representing a function. For instance `+`, `=`, `and`, ...
  /// </summary>
  [pbr::OriginalName("FUNCTION_SYMBOL")] FunctionSymbol = 4,
  /// <summary>
  /// List. Application of some parameters to a fluent symbol. For instance `(at-robot l1)` or `(battery-charged)`
  /// The first element of the list must be a FLUENT_SYMBOL
  /// </summary>
  [pbr::OriginalName("STATE_VARIABLE")] StateVariable = 5,
  /// <summary>
  /// List. The expression is the application of some parameters to a function. For instance `(+ 1 3)`.
  /// The first element of the list must be a FUNCTION_SYMBOL
  /// </summary>
  [pbr::OriginalName("FUNCTION_APPLICATION")] FunctionApplication = 6,
  /// <summary>
  /// Atom symbol. Unique identifier of a task or action in the current scope.
  /// </summary>
  [pbr::OriginalName("CONTAINER_ID")] ContainerId = 8,
}

/// <summary>
/// Features of the problem.
/// Features are essential in that not supporting a feature `X` should allow disregarding any field tagged with `features: [X]`.
/// </summary>
public enum Feature
{
  /// <summary>
  /// PROBLEM_CLASS
  /// </summary>
  [pbr::OriginalName("ACTION_BASED")] ActionBased = 0,
  [pbr::OriginalName("HIERARCHICAL")] Hierarchical = 26,
  [pbr::OriginalName("SCHEDULING")] Scheduling = 56,
  /// <summary>
  /// PROBLEM_TYPE
  /// </summary>
  [pbr::OriginalName("SIMPLE_NUMERIC_PLANNING")] SimpleNumericPlanning = 30,
  [pbr::OriginalName("GENERAL_NUMERIC_PLANNING")] GeneralNumericPlanning = 31,
  /// <summary>
  /// TIME
  /// </summary>
  [pbr::OriginalName("CONTINUOUS_TIME")] ContinuousTime = 1,
  [pbr::OriginalName("DISCRETE_TIME")] DiscreteTime = 2,
  [pbr::OriginalName("INTERMEDIATE_CONDITIONS_AND_EFFECTS")] IntermediateConditionsAndEffects = 3,
  [pbr::OriginalName("EXTERNAL_CONDITIONS_AND_EFFECTS")] ExternalConditionsAndEffects = 39,
  [pbr::OriginalName("TIMED_EFFECTS")] TimedEffects = 4,
  [pbr::OriginalName("TIMED_GOALS")] TimedGoals = 5,
  [pbr::OriginalName("DURATION_INEQUALITIES")] DurationInequalities = 6,
  [pbr::OriginalName("SELF_OVERLAPPING")] SelfOverlapping = 47,
  /// <summary>
  /// EXPRESSION_DURATION
  /// </summary>
  [pbr::OriginalName("STATIC_FLUENTS_IN_DURATIONS")] StaticFluentsInDurations = 27,
  [pbr::OriginalName("FLUENTS_IN_DURATIONS")] FluentsInDurations = 28,
  /// <summary>
  /// NUMBERS
  /// </summary>
  [pbr::OriginalName("CONTINUOUS_NUMBERS")] ContinuousNumbers = 7,
  [pbr::OriginalName("DISCRETE_NUMBERS")] DiscreteNumbers = 8,
  [pbr::OriginalName("BOUNDED_TYPES")] BoundedTypes = 38,
  /// <summary>
  /// CONDITIONS_KIND
  /// </summary>
  [pbr::OriginalName("NEGATIVE_CONDITIONS")] NegativeConditions = 9,
  [pbr::OriginalName("DISJUNCTIVE_CONDITIONS")] DisjunctiveConditions = 10,
  [pbr::OriginalName("EQUALITIES")] Equalities = 11,
  [pbr::OriginalName("EXISTENTIAL_CONDITIONS")] ExistentialConditions = 12,
  [pbr::OriginalName("UNIVERSAL_CONDITIONS")] UniversalConditions = 13,
  /// <summary>
  /// EFFECTS_KIND
  /// </summary>
  [pbr::OriginalName("CONDITIONAL_EFFECTS")] ConditionalEffects = 14,
  [pbr::OriginalName("INCREASE_EFFECTS")] IncreaseEffects = 15,
  [pbr::OriginalName("DECREASE_EFFECTS")] DecreaseEffects = 16,
  [pbr::OriginalName("STATIC_FLUENTS_IN_BOOLEAN_ASSIGNMENTS")] StaticFluentsInBooleanAssignments = 41,
  [pbr::OriginalName("STATIC_FLUENTS_IN_NUMERIC_ASSIGNMENTS")] StaticFluentsInNumericAssignments = 42,
  [pbr::OriginalName("STATIC_FLUENTS_IN_OBJECT_ASSIGNMENTS")] StaticFluentsInObjectAssignments = 57,
  [pbr::OriginalName("FLUENTS_IN_BOOLEAN_ASSIGNMENTS")] FluentsInBooleanAssignments = 43,
  [pbr::OriginalName("FLUENTS_IN_NUMERIC_ASSIGNMENTS")] FluentsInNumericAssignments = 44,
  [pbr::OriginalName("FLUENTS_IN_OBJECT_ASSIGNMENTS")] FluentsInObjectAssignments = 58,
  [pbr::OriginalName("FORALL_EFFECTS")] ForallEffects = 59,
  /// <summary>
  /// TYPING
  /// </summary>
  [pbr::OriginalName("FLAT_TYPING")] FlatTyping = 17,
  [pbr::OriginalName("HIERARCHICAL_TYPING")] HierarchicalTyping = 18,
  /// <summary>
  /// FLUENTS_TYPE
  /// </summary>
  [pbr::OriginalName("NUMERIC_FLUENTS")] NumericFluents = 19,
  [pbr::OriginalName("OBJECT_FLUENTS")] ObjectFluents = 20,
  /// <summary>
  /// PARAMETERS
  /// </summary>
  [pbr::OriginalName("BOOL_FLUENT_PARAMETERS")] BoolFluentParameters = 50,
  [pbr::OriginalName("BOUNDED_INT_FLUENT_PARAMETERS")] BoundedIntFluentParameters = 51,
  [pbr::OriginalName("BOOL_ACTION_PARAMETERS")] BoolActionParameters = 52,
  [pbr::OriginalName("BOUNDED_INT_ACTION_PARAMETERS")] BoundedIntActionParameters = 53,
  [pbr::OriginalName("UNBOUNDED_INT_ACTION_PARAMETERS")] UnboundedIntActionParameters = 54,
  [pbr::OriginalName("REAL_ACTION_PARAMETERS")] RealActionParameters = 55,
  /// <summary>
  /// QUALITY_METRICS
  /// </summary>
  [pbr::OriginalName("ACTIONS_COST")] ActionsCost = 21,
  [pbr::OriginalName("FINAL_VALUE")] FinalValue = 22,
  [pbr::OriginalName("MAKESPAN")] Makespan = 23,
  [pbr::OriginalName("PLAN_LENGTH")] PlanLength = 24,
  [pbr::OriginalName("OVERSUBSCRIPTION")] Oversubscription = 29,
  [pbr::OriginalName("TEMPORAL_OVERSUBSCRIPTION")] TemporalOversubscription = 40,
  /// <summary>
  /// ACTION_COST_KIND
  /// </summary>
  [pbr::OriginalName("STATIC_FLUENTS_IN_ACTIONS_COST")] StaticFluentsInActionsCost = 45,
  [pbr::OriginalName("FLUENTS_IN_ACTIONS_COST")] FluentsInActionsCost = 46,
  /// <summary>
  /// SIMULATED_ENTITIES
  /// </summary>
  [pbr::OriginalName("SIMULATED_EFFECTS")] SimulatedEffects = 25,
  /// <summary>
  /// CONSTRAINTS_KIND
  /// </summary>
  [pbr::OriginalName("TRAJECTORY_CONSTRAINTS")] TrajectoryConstraints = 48,
  [pbr::OriginalName("STATE_INVARIANTS")] StateInvariants = 49,
  /// <summary>
  /// HIERARCHICAL
  /// </summary>
  [pbr::OriginalName("METHOD_PRECONDITIONS")] MethodPreconditions = 32,
  [pbr::OriginalName("TASK_NETWORK_CONSTRAINTS")] TaskNetworkConstraints = 33,
  [pbr::OriginalName("INITIAL_TASK_NETWORK_VARIABLES")] InitialTaskNetworkVariables = 34,
  [pbr::OriginalName("TASK_ORDER_TOTAL")] TaskOrderTotal = 35,
  [pbr::OriginalName("TASK_ORDER_PARTIAL")] TaskOrderPartial = 36,
  [pbr::OriginalName("TASK_ORDER_TEMPORAL")] TaskOrderTemporal = 37,
}

#endregion

#region Messages
/// <summary>
/// As in s-expression, an Expression is either an atom or list representing the application of some parameters to a function/fluent.
/// </summary>
public sealed partial class Expression : pb::IMessage<Expression>
{
  private static readonly pb::MessageParser<Expression> _parser = new pb::MessageParser<Expression>(() => new Expression());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Expression> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[0]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Expression()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Expression(Expression other) : this()
  {
    atom_ = other.atom_ != null ? other.atom_.Clone() : null;
    list_ = other.list_.Clone();
    type_ = other.type_;
    kind_ = other.kind_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Expression Clone()
  {
    return new Expression(this);
  }

  /// <summary>Field number for the "atom" field.</summary>
  public const int AtomFieldNumber = 1;
  private global::Atom atom_;
  /// <summary>
  /// If non-empty, the expression is a single atom.
  /// For instance `3`, `+`, `kitchen`, `at-robot`, ...
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Atom Atom
  {
    get { return atom_; }
    set
    {
      atom_ = value;
    }
  }

  /// <summary>Field number for the "list" field.</summary>
  public const int ListFieldNumber = 2;
  private static readonly pb::FieldCodec<global::Expression> _repeated_list_codec
      = pb::FieldCodec.ForMessage(18, global::Expression.Parser);
  private readonly pbc::RepeatedField<global::Expression> list_ = new pbc::RepeatedField<global::Expression>();
  /// <summary>
  /// If the `atom` field is empty, then the expression is a list of sub-expressions,
  /// typically representing the application of some arguments to a function or fluent.
  /// For instance `(+ 1 3)`, (at-robot l1)`, `(>= (battery_level) 20)`
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Expression> List
  {
    get { return list_; }
  }

  /// <summary>Field number for the "type" field.</summary>
  public const int TypeFieldNumber = 3;
  private string type_ = "";
  /// <summary>
  /// Type of the expression. For instance "int", "location", ...
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Type
  {
    get { return type_; }
    set
    {
      type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "kind" field.</summary>
  public const int KindFieldNumber = 4;
  private global::ExpressionKind kind_ = 0;
  /// <summary>
  /// Kind of the expression, specifying the content of the expression.
  /// This is intended to facilitate parsing of the expression.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::ExpressionKind Kind
  {
    get { return kind_; }
    set
    {
      kind_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Expression);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Expression other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Atom, other.Atom)) return false;
    if (!list_.Equals(other.list_)) return false;
    if (Type != other.Type) return false;
    if (Kind != other.Kind) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (atom_ != null) hash ^= Atom.GetHashCode();
    hash ^= list_.GetHashCode();
    if (Type.Length != 0) hash ^= Type.GetHashCode();
    if (Kind != 0) hash ^= Kind.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (atom_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Atom);
    }
    list_.WriteTo(output, _repeated_list_codec);
    if (Type.Length != 0)
    {
      output.WriteRawTag(26);
      output.WriteString(Type);
    }
    if (Kind != 0)
    {
      output.WriteRawTag(32);
      output.WriteEnum((int)Kind);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (atom_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Atom);
    }
    size += list_.CalculateSize(_repeated_list_codec);
    if (Type.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
    }
    if (Kind != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Kind);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Expression other)
  {
    if (other == null)
    {
      return;
    }
    if (other.atom_ != null)
    {
      if (atom_ == null)
      {
        atom_ = new global::Atom();
      }
      Atom.MergeFrom(other.Atom);
    }
    list_.Add(other.list_);
    if (other.Type.Length != 0)
    {
      Type = other.Type;
    }
    if (other.Kind != 0)
    {
      Kind = other.Kind;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (atom_ == null)
            {
              atom_ = new global::Atom();
            }
            input.ReadMessage(atom_);
            break;
          }
        case 18:
          {
            list_.AddEntriesFrom(input, _repeated_list_codec);
            break;
          }
        case 26:
          {
            Type = input.ReadString();
            break;
          }
        case 32:
          {
            kind_ = (global::ExpressionKind)input.ReadEnum();
            break;
          }
      }
    }
  }

}

public sealed partial class Atom : pb::IMessage<Atom>
{
  private static readonly pb::MessageParser<Atom> _parser = new pb::MessageParser<Atom>(() => new Atom());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Atom> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[1]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Atom()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Atom(Atom other) : this()
  {
    switch (other.ContentCase)
    {
      case ContentOneofCase.Symbol:
        Symbol = other.Symbol;
        break;
      case ContentOneofCase.Int:
        Int = other.Int;
        break;
      case ContentOneofCase.Real:
        Real = other.Real.Clone();
        break;
      case ContentOneofCase.Boolean:
        Boolean = other.Boolean;
        break;
    }

    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Atom Clone()
  {
    return new Atom(this);
  }

  /// <summary>Field number for the "symbol" field.</summary>
  public const int SymbolFieldNumber = 1;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Symbol
  {
    get { return contentCase_ == ContentOneofCase.Symbol ? (string)content_ : ""; }
    set
    {
      content_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      contentCase_ = ContentOneofCase.Symbol;
    }
  }

  /// <summary>Field number for the "int" field.</summary>
  public const int IntFieldNumber = 2;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public long Int
  {
    get { return contentCase_ == ContentOneofCase.Int ? (long)content_ : 0L; }
    set
    {
      content_ = value;
      contentCase_ = ContentOneofCase.Int;
    }
  }

  /// <summary>Field number for the "real" field.</summary>
  public const int RealFieldNumber = 3;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Real Real
  {
    get { return contentCase_ == ContentOneofCase.Real ? (global::Real)content_ : null; }
    set
    {
      content_ = value;
      contentCase_ = value == null ? ContentOneofCase.None : ContentOneofCase.Real;
    }
  }

  /// <summary>Field number for the "boolean" field.</summary>
  public const int BooleanFieldNumber = 4;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Boolean
  {
    get { return contentCase_ == ContentOneofCase.Boolean ? (bool)content_ : false; }
    set
    {
      content_ = value;
      contentCase_ = ContentOneofCase.Boolean;
    }
  }

  private object content_;
  /// <summary>Enum of possible cases for the "content" oneof.</summary>
  public enum ContentOneofCase
  {
    None = 0,
    Symbol = 1,
    Int = 2,
    Real = 3,
    Boolean = 4,
  }
  private ContentOneofCase contentCase_ = ContentOneofCase.None;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ContentOneofCase ContentCase
  {
    get { return contentCase_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void ClearContent()
  {
    contentCase_ = ContentOneofCase.None;
    content_ = null;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Atom);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Atom other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Symbol != other.Symbol) return false;
    if (Int != other.Int) return false;
    if (!object.Equals(Real, other.Real)) return false;
    if (Boolean != other.Boolean) return false;
    if (ContentCase != other.ContentCase) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (contentCase_ == ContentOneofCase.Symbol) hash ^= Symbol.GetHashCode();
    if (contentCase_ == ContentOneofCase.Int) hash ^= Int.GetHashCode();
    if (contentCase_ == ContentOneofCase.Real) hash ^= Real.GetHashCode();
    if (contentCase_ == ContentOneofCase.Boolean) hash ^= Boolean.GetHashCode();
    hash ^= (int)contentCase_;
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (contentCase_ == ContentOneofCase.Symbol)
    {
      output.WriteRawTag(10);
      output.WriteString(Symbol);
    }
    if (contentCase_ == ContentOneofCase.Int)
    {
      output.WriteRawTag(16);
      output.WriteInt64(Int);
    }
    if (contentCase_ == ContentOneofCase.Real)
    {
      output.WriteRawTag(26);
      output.WriteMessage(Real);
    }
    if (contentCase_ == ContentOneofCase.Boolean)
    {
      output.WriteRawTag(32);
      output.WriteBool(Boolean);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (contentCase_ == ContentOneofCase.Symbol)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Symbol);
    }
    if (contentCase_ == ContentOneofCase.Int)
    {
      size += 1 + pb::CodedOutputStream.ComputeInt64Size(Int);
    }
    if (contentCase_ == ContentOneofCase.Real)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Real);
    }
    if (contentCase_ == ContentOneofCase.Boolean)
    {
      size += 1 + 1;
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Atom other)
  {
    if (other == null)
    {
      return;
    }
    switch (other.ContentCase)
    {
      case ContentOneofCase.Symbol:
        Symbol = other.Symbol;
        break;
      case ContentOneofCase.Int:
        Int = other.Int;
        break;
      case ContentOneofCase.Real:
        if (Real == null)
        {
          Real = new global::Real();
        }
        Real.MergeFrom(other.Real);
        break;
      case ContentOneofCase.Boolean:
        Boolean = other.Boolean;
        break;
    }

    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Symbol = input.ReadString();
            break;
          }
        case 16:
          {
            Int = input.ReadInt64();
            break;
          }
        case 26:
          {
            global::Real subBuilder = new global::Real();
            if (contentCase_ == ContentOneofCase.Real)
            {
              subBuilder.MergeFrom(Real);
            }
            input.ReadMessage(subBuilder);
            Real = subBuilder;
            break;
          }
        case 32:
          {
            Boolean = input.ReadBool();
            break;
          }
      }
    }
  }

}

/// <summary>
/// Representation of a constant real number, as the fraction `(numerator / denominator)`.
/// A real should be in its canonical form (with smallest possible denominator).
/// Notably, if this number is an integer, then it is guaranteed that `denominator == 1`.
/// </summary>
public sealed partial class Real : pb::IMessage<Real>
{
  private static readonly pb::MessageParser<Real> _parser = new pb::MessageParser<Real>(() => new Real());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Real> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[2]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Real()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Real(Real other) : this()
  {
    numerator_ = other.numerator_;
    denominator_ = other.denominator_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Real Clone()
  {
    return new Real(this);
  }

  /// <summary>Field number for the "numerator" field.</summary>
  public const int NumeratorFieldNumber = 1;
  private long numerator_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public long Numerator
  {
    get { return numerator_; }
    set
    {
      numerator_ = value;
    }
  }

  /// <summary>Field number for the "denominator" field.</summary>
  public const int DenominatorFieldNumber = 2;
  private long denominator_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public long Denominator
  {
    get { return denominator_; }
    set
    {
      denominator_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Real);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Real other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Numerator != other.Numerator) return false;
    if (Denominator != other.Denominator) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Numerator != 0L) hash ^= Numerator.GetHashCode();
    if (Denominator != 0L) hash ^= Denominator.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Numerator != 0L)
    {
      output.WriteRawTag(8);
      output.WriteInt64(Numerator);
    }
    if (Denominator != 0L)
    {
      output.WriteRawTag(16);
      output.WriteInt64(Denominator);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Numerator != 0L)
    {
      size += 1 + pb::CodedOutputStream.ComputeInt64Size(Numerator);
    }
    if (Denominator != 0L)
    {
      size += 1 + pb::CodedOutputStream.ComputeInt64Size(Denominator);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Real other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Numerator != 0L)
    {
      Numerator = other.Numerator;
    }
    if (other.Denominator != 0L)
    {
      Denominator = other.Denominator;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            Numerator = input.ReadInt64();
            break;
          }
        case 16:
          {
            Denominator = input.ReadInt64();
            break;
          }
      }
    }
  }

}

/// <summary>
/// Declares the existence of a symbolic type.
/// </summary>
public sealed partial class TypeDeclaration : pb::IMessage<TypeDeclaration>
{
  private static readonly pb::MessageParser<TypeDeclaration> _parser = new pb::MessageParser<TypeDeclaration>(() => new TypeDeclaration());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<TypeDeclaration> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[3]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TypeDeclaration()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TypeDeclaration(TypeDeclaration other) : this()
  {
    typeName_ = other.typeName_;
    parentType_ = other.parentType_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TypeDeclaration Clone()
  {
    return new TypeDeclaration(this);
  }

  /// <summary>Field number for the "type_name" field.</summary>
  public const int TypeNameFieldNumber = 1;
  private string typeName_ = "";
  /// <summary>
  /// Name of the type that is declared.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string TypeName
  {
    get { return typeName_; }
    set
    {
      typeName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parent_type" field.</summary>
  public const int ParentTypeFieldNumber = 2;
  private string parentType_ = "";
  /// <summary>
  /// Optional. If the string is non-empty, this is the parent type of `type_name`.
  /// If set, the parent type must have been previously declared (i.e. should appear earlier in the problem's type declarations.
  /// feature: HIERARCHICAL_TYPING
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string ParentType
  {
    get { return parentType_; }
    set
    {
      parentType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as TypeDeclaration);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(TypeDeclaration other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (TypeName != other.TypeName) return false;
    if (ParentType != other.ParentType) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (TypeName.Length != 0) hash ^= TypeName.GetHashCode();
    if (ParentType.Length != 0) hash ^= ParentType.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (TypeName.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(TypeName);
    }
    if (ParentType.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(ParentType);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (TypeName.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(TypeName);
    }
    if (ParentType.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(ParentType);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(TypeDeclaration other)
  {
    if (other == null)
    {
      return;
    }
    if (other.TypeName.Length != 0)
    {
      TypeName = other.TypeName;
    }
    if (other.ParentType.Length != 0)
    {
      ParentType = other.ParentType;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            TypeName = input.ReadString();
            break;
          }
        case 18:
          {
            ParentType = input.ReadString();
            break;
          }
      }
    }
  }

}

/// <summary>
/// Parameter of a fluent or of an action
/// </summary>
public sealed partial class Parameter : pb::IMessage<Parameter>
{
  private static readonly pb::MessageParser<Parameter> _parser = new pb::MessageParser<Parameter>(() => new Parameter());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Parameter> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[4]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Parameter()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Parameter(Parameter other) : this()
  {
    name_ = other.name_;
    type_ = other.type_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Parameter Clone()
  {
    return new Parameter(this);
  }

  /// <summary>Field number for the "name" field.</summary>
  public const int NameFieldNumber = 1;
  private string name_ = "";
  /// <summary>
  /// Name of the parameter.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Name
  {
    get { return name_; }
    set
    {
      name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "type" field.</summary>
  public const int TypeFieldNumber = 2;
  private string type_ = "";
  /// <summary>
  /// Type of the parameter.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Type
  {
    get { return type_; }
    set
    {
      type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Parameter);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Parameter other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Name != other.Name) return false;
    if (Type != other.Type) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    if (Type.Length != 0) hash ^= Type.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Name.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    if (Type.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(Type);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Name.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    if (Type.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Parameter other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Name.Length != 0)
    {
      Name = other.Name;
    }
    if (other.Type.Length != 0)
    {
      Type = other.Type;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Name = input.ReadString();
            break;
          }
        case 18:
          {
            Type = input.ReadString();
            break;
          }
      }
    }
  }

}

/// <summary>
/// A state-dependent variable.
/// </summary>
public sealed partial class Fluent : pb::IMessage<Fluent>
{
  private static readonly pb::MessageParser<Fluent> _parser = new pb::MessageParser<Fluent>(() => new Fluent());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Fluent> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[5]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Fluent()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Fluent(Fluent other) : this()
  {
    name_ = other.name_;
    valueType_ = other.valueType_;
    parameters_ = other.parameters_.Clone();
    defaultValue_ = other.defaultValue_ != null ? other.defaultValue_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Fluent Clone()
  {
    return new Fluent(this);
  }

  /// <summary>Field number for the "name" field.</summary>
  public const int NameFieldNumber = 1;
  private string name_ = "";
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Name
  {
    get { return name_; }
    set
    {
      name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "value_type" field.</summary>
  public const int ValueTypeFieldNumber = 2;
  private string valueType_ = "";
  /// <summary>
  /// Return type of the fluent.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string ValueType
  {
    get { return valueType_; }
    set
    {
      valueType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parameters" field.</summary>
  public const int ParametersFieldNumber = 3;
  private static readonly pb::FieldCodec<global::Parameter> _repeated_parameters_codec
      = pb::FieldCodec.ForMessage(26, global::Parameter.Parser);
  private readonly pbc::RepeatedField<global::Parameter> parameters_ = new pbc::RepeatedField<global::Parameter>();
  /// <summary>
  /// Typed and named parameters of the fluent.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Parameter> Parameters
  {
    get { return parameters_; }
  }

  /// <summary>Field number for the "default_value" field.</summary>
  public const int DefaultValueFieldNumber = 4;
  private global::Expression defaultValue_;
  /// <summary>
  /// If non-empty, then any state variable using this fluent that is not explicitly given a value in the initial state
  /// will be assumed to have this default value.
  /// This allows mimicking the closed world assumption by setting a "false" default value to predicates.
  /// Note that in the initial state of the problem message, it is assumed that all default values are set.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression DefaultValue
  {
    get { return defaultValue_; }
    set
    {
      defaultValue_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Fluent);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Fluent other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Name != other.Name) return false;
    if (ValueType != other.ValueType) return false;
    if (!parameters_.Equals(other.parameters_)) return false;
    if (!object.Equals(DefaultValue, other.DefaultValue)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    if (ValueType.Length != 0) hash ^= ValueType.GetHashCode();
    hash ^= parameters_.GetHashCode();
    if (defaultValue_ != null) hash ^= DefaultValue.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Name.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    if (ValueType.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(ValueType);
    }
    parameters_.WriteTo(output, _repeated_parameters_codec);
    if (defaultValue_ != null)
    {
      output.WriteRawTag(34);
      output.WriteMessage(DefaultValue);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Name.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    if (ValueType.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(ValueType);
    }
    size += parameters_.CalculateSize(_repeated_parameters_codec);
    if (defaultValue_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultValue);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Fluent other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Name.Length != 0)
    {
      Name = other.Name;
    }
    if (other.ValueType.Length != 0)
    {
      ValueType = other.ValueType;
    }
    parameters_.Add(other.parameters_);
    if (other.defaultValue_ != null)
    {
      if (defaultValue_ == null)
      {
        defaultValue_ = new global::Expression();
      }
      DefaultValue.MergeFrom(other.DefaultValue);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Name = input.ReadString();
            break;
          }
        case 18:
          {
            ValueType = input.ReadString();
            break;
          }
        case 26:
          {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
        case 34:
          {
            if (defaultValue_ == null)
            {
              defaultValue_ = new global::Expression();
            }
            input.ReadMessage(defaultValue_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Declares an object with the given name and type.
/// </summary>
public sealed partial class ObjectDeclaration : pb::IMessage<ObjectDeclaration>
{
  private static readonly pb::MessageParser<ObjectDeclaration> _parser = new pb::MessageParser<ObjectDeclaration>(() => new ObjectDeclaration());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<ObjectDeclaration> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[6]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ObjectDeclaration()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ObjectDeclaration(ObjectDeclaration other) : this()
  {
    name_ = other.name_;
    type_ = other.type_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ObjectDeclaration Clone()
  {
    return new ObjectDeclaration(this);
  }

  /// <summary>Field number for the "name" field.</summary>
  public const int NameFieldNumber = 1;
  private string name_ = "";
  /// <summary>
  /// Name of the object.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Name
  {
    get { return name_; }
    set
    {
      name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "type" field.</summary>
  public const int TypeFieldNumber = 2;
  private string type_ = "";
  /// <summary>
  /// Type of the object.
  /// The type must have been previously declared in the problem definition.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Type
  {
    get { return type_; }
    set
    {
      type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as ObjectDeclaration);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(ObjectDeclaration other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Name != other.Name) return false;
    if (Type != other.Type) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    if (Type.Length != 0) hash ^= Type.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Name.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    if (Type.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(Type);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Name.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    if (Type.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(ObjectDeclaration other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Name.Length != 0)
    {
      Name = other.Name;
    }
    if (other.Type.Length != 0)
    {
      Type = other.Type;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Name = input.ReadString();
            break;
          }
        case 18:
          {
            Type = input.ReadString();
            break;
          }
      }
    }
  }

}

/// <summary>
/// An effect expression is of the form `FLUENT OP VALUE`.
/// We explicitly restrict the different types of effects by setting the allowed operators.
/// </summary>
public sealed partial class EffectExpression : pb::IMessage<EffectExpression>
{
  private static readonly pb::MessageParser<EffectExpression> _parser = new pb::MessageParser<EffectExpression>(() => new EffectExpression());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<EffectExpression> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[7]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public EffectExpression()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public EffectExpression(EffectExpression other) : this()
  {
    kind_ = other.kind_;
    fluent_ = other.fluent_ != null ? other.fluent_.Clone() : null;
    value_ = other.value_ != null ? other.value_.Clone() : null;
    condition_ = other.condition_ != null ? other.condition_.Clone() : null;
    forall_ = other.forall_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public EffectExpression Clone()
  {
    return new EffectExpression(this);
  }

  /// <summary>Field number for the "kind" field.</summary>
  public const int KindFieldNumber = 1;
  private global::EffectExpression.Types.EffectKind kind_ = 0;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::EffectExpression.Types.EffectKind Kind
  {
    get { return kind_; }
    set
    {
      kind_ = value;
    }
  }

  /// <summary>Field number for the "fluent" field.</summary>
  public const int FluentFieldNumber = 2;
  private global::Expression fluent_;
  /// <summary>
  /// Expression that must be of the STATE_VARIABLE kind.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Fluent
  {
    get { return fluent_; }
    set
    {
      fluent_ = value;
    }
  }

  /// <summary>Field number for the "value" field.</summary>
  public const int ValueFieldNumber = 3;
  private global::Expression value_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Value
  {
    get { return value_; }
    set
    {
      value_ = value;
    }
  }

  /// <summary>Field number for the "condition" field.</summary>
  public const int ConditionFieldNumber = 4;
  private global::Expression condition_;
  /// <summary>
  /// Optional. If the effect is conditional, then the following field must be set.
  /// In this case, the `effect` will only be applied if the `condition`` holds.
  /// If the effect is unconditional, the effect is set to the constant 'true' value.
  /// features: CONDITIONAL_EFFECT
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Condition
  {
    get { return condition_; }
    set
    {
      condition_ = value;
    }
  }

  /// <summary>Field number for the "forall" field.</summary>
  public const int ForallFieldNumber = 5;
  private static readonly pb::FieldCodec<global::Expression> _repeated_forall_codec
      = pb::FieldCodec.ForMessage(42, global::Expression.Parser);
  private readonly pbc::RepeatedField<global::Expression> forall_ = new pbc::RepeatedField<global::Expression>();
  /// <summary>
  /// The variables that quantify this effect
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Expression> Forall
  {
    get { return forall_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as EffectExpression);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(EffectExpression other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Kind != other.Kind) return false;
    if (!object.Equals(Fluent, other.Fluent)) return false;
    if (!object.Equals(Value, other.Value)) return false;
    if (!object.Equals(Condition, other.Condition)) return false;
    if (!forall_.Equals(other.forall_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Kind != 0) hash ^= Kind.GetHashCode();
    if (fluent_ != null) hash ^= Fluent.GetHashCode();
    if (value_ != null) hash ^= Value.GetHashCode();
    if (condition_ != null) hash ^= Condition.GetHashCode();
    hash ^= forall_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Kind != 0)
    {
      output.WriteRawTag(8);
      output.WriteEnum((int)Kind);
    }
    if (fluent_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Fluent);
    }
    if (value_ != null)
    {
      output.WriteRawTag(26);
      output.WriteMessage(Value);
    }
    if (condition_ != null)
    {
      output.WriteRawTag(34);
      output.WriteMessage(Condition);
    }
    forall_.WriteTo(output, _repeated_forall_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Kind != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Kind);
    }
    if (fluent_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Fluent);
    }
    if (value_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Value);
    }
    if (condition_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Condition);
    }
    size += forall_.CalculateSize(_repeated_forall_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(EffectExpression other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Kind != 0)
    {
      Kind = other.Kind;
    }
    if (other.fluent_ != null)
    {
      if (fluent_ == null)
      {
        fluent_ = new global::Expression();
      }
      Fluent.MergeFrom(other.Fluent);
    }
    if (other.value_ != null)
    {
      if (value_ == null)
      {
        value_ = new global::Expression();
      }
      Value.MergeFrom(other.Value);
    }
    if (other.condition_ != null)
    {
      if (condition_ == null)
      {
        condition_ = new global::Expression();
      }
      Condition.MergeFrom(other.Condition);
    }
    forall_.Add(other.forall_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            kind_ = (global::EffectExpression.Types.EffectKind)input.ReadEnum();
            break;
          }
        case 18:
          {
            if (fluent_ == null)
            {
              fluent_ = new global::Expression();
            }
            input.ReadMessage(fluent_);
            break;
          }
        case 26:
          {
            if (value_ == null)
            {
              value_ = new global::Expression();
            }
            input.ReadMessage(value_);
            break;
          }
        case 34:
          {
            if (condition_ == null)
            {
              condition_ = new global::Expression();
            }
            input.ReadMessage(condition_);
            break;
          }
        case 42:
          {
            forall_.AddEntriesFrom(input, _repeated_forall_codec);
            break;
          }
      }
    }
  }

  #region Nested types
  /// <summary>Container for nested types declared in the EffectExpression message type.</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static partial class Types
  {
    public enum EffectKind
    {
      /// <summary>
      /// The `fluent` is set to the corresponding `value`
      /// </summary>
      [pbr::OriginalName("ASSIGN")] Assign = 0,
      /// <summary>
      /// The `fluent` is increased by the amount `value`
      /// features: INCREASE_EFFECTS
      /// </summary>
      [pbr::OriginalName("INCREASE")] Increase = 1,
      /// <summary>
      /// The `fluent` is decreased by the amount `value`
      /// features: DECREASE_EFFECTS
      /// </summary>
      [pbr::OriginalName("DECREASE")] Decrease = 2,
    }

  }
  #endregion

}

/// <summary>
/// Representation of an effect that allows qualifying the effect expression, e.g., to make it a conditional effect.
/// </summary>
public sealed partial class Effect : pb::IMessage<Effect>
{
  private static readonly pb::MessageParser<Effect> _parser = new pb::MessageParser<Effect>(() => new Effect());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Effect> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[8]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Effect()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Effect(Effect other) : this()
  {
    effect_ = other.effect_ != null ? other.effect_.Clone() : null;
    occurrenceTime_ = other.occurrenceTime_ != null ? other.occurrenceTime_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Effect Clone()
  {
    return new Effect(this);
  }

  /// <summary>Field number for the "effect" field.</summary>
  public const int Effect_FieldNumber = 1;
  private global::EffectExpression effect_;
  /// <summary>
  /// Required. The actual effect that should take place.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::EffectExpression Effect_
  {
    get { return effect_; }
    set
    {
      effect_ = value;
    }
  }

  /// <summary>Field number for the "occurrence_time" field.</summary>
  public const int OccurrenceTimeFieldNumber = 2;
  private global::Timing occurrenceTime_;
  /// <summary>
  /// Optional. If the effect is within a durative action, the following must be set and will specify when the effect takes place.
  /// features: DURATIVE_ACTIONS
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Timing OccurrenceTime
  {
    get { return occurrenceTime_; }
    set
    {
      occurrenceTime_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Effect);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Effect other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Effect_, other.Effect_)) return false;
    if (!object.Equals(OccurrenceTime, other.OccurrenceTime)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (effect_ != null) hash ^= Effect_.GetHashCode();
    if (occurrenceTime_ != null) hash ^= OccurrenceTime.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (effect_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Effect_);
    }
    if (occurrenceTime_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(OccurrenceTime);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (effect_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Effect_);
    }
    if (occurrenceTime_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(OccurrenceTime);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Effect other)
  {
    if (other == null)
    {
      return;
    }
    if (other.effect_ != null)
    {
      if (effect_ == null)
      {
        effect_ = new global::EffectExpression();
      }
      Effect_.MergeFrom(other.Effect_);
    }
    if (other.occurrenceTime_ != null)
    {
      if (occurrenceTime_ == null)
      {
        occurrenceTime_ = new global::Timing();
      }
      OccurrenceTime.MergeFrom(other.OccurrenceTime);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (effect_ == null)
            {
              effect_ = new global::EffectExpression();
            }
            input.ReadMessage(effect_);
            break;
          }
        case 18:
          {
            if (occurrenceTime_ == null)
            {
              occurrenceTime_ = new global::Timing();
            }
            input.ReadMessage(occurrenceTime_);
            break;
          }
      }
    }
  }

}

public sealed partial class Condition : pb::IMessage<Condition>
{
  private static readonly pb::MessageParser<Condition> _parser = new pb::MessageParser<Condition>(() => new Condition());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Condition> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[9]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Condition()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Condition(Condition other) : this()
  {
    cond_ = other.cond_ != null ? other.cond_.Clone() : null;
    span_ = other.span_ != null ? other.span_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Condition Clone()
  {
    return new Condition(this);
  }

  /// <summary>Field number for the "cond" field.</summary>
  public const int CondFieldNumber = 1;
  private global::Expression cond_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Cond
  {
    get { return cond_; }
    set
    {
      cond_ = value;
    }
  }

  /// <summary>Field number for the "span" field.</summary>
  public const int SpanFieldNumber = 2;
  private global::TimeInterval span_;
  /// <summary>
  /// Optional. Must be set for durative actions where it specifies the temporal interval
  /// over which when the condition should hold.
  /// features: DURATIVE_ACTIONS
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::TimeInterval Span
  {
    get { return span_; }
    set
    {
      span_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Condition);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Condition other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Cond, other.Cond)) return false;
    if (!object.Equals(Span, other.Span)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (cond_ != null) hash ^= Cond.GetHashCode();
    if (span_ != null) hash ^= Span.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (cond_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Cond);
    }
    if (span_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Span);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (cond_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Cond);
    }
    if (span_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Span);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Condition other)
  {
    if (other == null)
    {
      return;
    }
    if (other.cond_ != null)
    {
      if (cond_ == null)
      {
        cond_ = new global::Expression();
      }
      Cond.MergeFrom(other.Cond);
    }
    if (other.span_ != null)
    {
      if (span_ == null)
      {
        span_ = new global::TimeInterval();
      }
      Span.MergeFrom(other.Span);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (cond_ == null)
            {
              cond_ = new global::Expression();
            }
            input.ReadMessage(cond_);
            break;
          }
        case 18:
          {
            if (span_ == null)
            {
              span_ = new global::TimeInterval();
            }
            input.ReadMessage(span_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Unified action representation that represents any kind of actions.
/// </summary>
public sealed partial class Action : pb::IMessage<Action>
{
  private static readonly pb::MessageParser<Action> _parser = new pb::MessageParser<Action>(() => new Action());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Action> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[10]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Action()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Action(Action other) : this()
  {
    name_ = other.name_;
    parameters_ = other.parameters_.Clone();
    duration_ = other.duration_ != null ? other.duration_.Clone() : null;
    conditions_ = other.conditions_.Clone();
    effects_ = other.effects_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Action Clone()
  {
    return new Action(this);
  }

  /// <summary>Field number for the "name" field.</summary>
  public const int NameFieldNumber = 1;
  private string name_ = "";
  /// <summary>
  /// Action name. E.g. "move"
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Name
  {
    get { return name_; }
    set
    {
      name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parameters" field.</summary>
  public const int ParametersFieldNumber = 2;
  private static readonly pb::FieldCodec<global::Parameter> _repeated_parameters_codec
      = pb::FieldCodec.ForMessage(18, global::Parameter.Parser);
  private readonly pbc::RepeatedField<global::Parameter> parameters_ = new pbc::RepeatedField<global::Parameter>();
  /// <summary>
  /// Typed and named parameters of the action.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Parameter> Parameters
  {
    get { return parameters_; }
  }

  /// <summary>Field number for the "duration" field.</summary>
  public const int DurationFieldNumber = 3;
  private global::Duration duration_;
  /// <summary>
  /// If set, the action is durative. Otherwise it is instantaneous.
  /// features: DURATIVE_ACTIONS
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Duration Duration
  {
    get { return duration_; }
    set
    {
      duration_ = value;
    }
  }

  /// <summary>Field number for the "conditions" field.</summary>
  public const int ConditionsFieldNumber = 4;
  private static readonly pb::FieldCodec<global::Condition> _repeated_conditions_codec
      = pb::FieldCodec.ForMessage(34, global::Condition.Parser);
  private readonly pbc::RepeatedField<global::Condition> conditions_ = new pbc::RepeatedField<global::Condition>();
  /// <summary>
  /// Conjunction of conditions that must hold for the action to be applicable.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Condition> Conditions
  {
    get { return conditions_; }
  }

  /// <summary>Field number for the "effects" field.</summary>
  public const int EffectsFieldNumber = 5;
  private static readonly pb::FieldCodec<global::Effect> _repeated_effects_codec
      = pb::FieldCodec.ForMessage(42, global::Effect.Parser);
  private readonly pbc::RepeatedField<global::Effect> effects_ = new pbc::RepeatedField<global::Effect>();
  /// <summary>
  /// Conjunction of effects as a result of applying this action.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Effect> Effects
  {
    get { return effects_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Action);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Action other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Name != other.Name) return false;
    if (!parameters_.Equals(other.parameters_)) return false;
    if (!object.Equals(Duration, other.Duration)) return false;
    if (!conditions_.Equals(other.conditions_)) return false;
    if (!effects_.Equals(other.effects_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    hash ^= parameters_.GetHashCode();
    if (duration_ != null) hash ^= Duration.GetHashCode();
    hash ^= conditions_.GetHashCode();
    hash ^= effects_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Name.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    parameters_.WriteTo(output, _repeated_parameters_codec);
    if (duration_ != null)
    {
      output.WriteRawTag(26);
      output.WriteMessage(Duration);
    }
    conditions_.WriteTo(output, _repeated_conditions_codec);
    effects_.WriteTo(output, _repeated_effects_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Name.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    size += parameters_.CalculateSize(_repeated_parameters_codec);
    if (duration_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
    }
    size += conditions_.CalculateSize(_repeated_conditions_codec);
    size += effects_.CalculateSize(_repeated_effects_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Action other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Name.Length != 0)
    {
      Name = other.Name;
    }
    parameters_.Add(other.parameters_);
    if (other.duration_ != null)
    {
      if (duration_ == null)
      {
        duration_ = new global::Duration();
      }
      Duration.MergeFrom(other.Duration);
    }
    conditions_.Add(other.conditions_);
    effects_.Add(other.effects_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Name = input.ReadString();
            break;
          }
        case 18:
          {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
        case 26:
          {
            if (duration_ == null)
            {
              duration_ = new global::Duration();
            }
            input.ReadMessage(duration_);
            break;
          }
        case 34:
          {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
        case 42:
          {
            effects_.AddEntriesFrom(input, _repeated_effects_codec);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Symbolic reference to an absolute time.
/// It might represent:
/// - the time of the initial/final state, or
/// - the start/end of the containing action, or
/// - the start/end of one of the subtask in the context of a method or of a task network.
/// </summary>
public sealed partial class Timepoint : pb::IMessage<Timepoint>
{
  private static readonly pb::MessageParser<Timepoint> _parser = new pb::MessageParser<Timepoint>(() => new Timepoint());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Timepoint> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[11]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Timepoint()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Timepoint(Timepoint other) : this()
  {
    kind_ = other.kind_;
    containerId_ = other.containerId_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Timepoint Clone()
  {
    return new Timepoint(this);
  }

  /// <summary>Field number for the "kind" field.</summary>
  public const int KindFieldNumber = 1;
  private global::Timepoint.Types.TimepointKind kind_ = 0;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Timepoint.Types.TimepointKind Kind
  {
    get { return kind_; }
    set
    {
      kind_ = value;
    }
  }

  /// <summary>Field number for the "container_id" field.</summary>
  public const int ContainerIdFieldNumber = 2;
  private string containerId_ = "";
  /// <summary>
  /// If non-empty, identifies the container of which we are extracting the start/end timepoint.
  /// In the context of a task-network or of a method, this could be the `id` of one of the subtasks.
  /// feature: hierarchies
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string ContainerId
  {
    get { return containerId_; }
    set
    {
      containerId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Timepoint);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Timepoint other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Kind != other.Kind) return false;
    if (ContainerId != other.ContainerId) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Kind != 0) hash ^= Kind.GetHashCode();
    if (ContainerId.Length != 0) hash ^= ContainerId.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Kind != 0)
    {
      output.WriteRawTag(8);
      output.WriteEnum((int)Kind);
    }
    if (ContainerId.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(ContainerId);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Kind != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Kind);
    }
    if (ContainerId.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(ContainerId);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Timepoint other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Kind != 0)
    {
      Kind = other.Kind;
    }
    if (other.ContainerId.Length != 0)
    {
      ContainerId = other.ContainerId;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            kind_ = (global::Timepoint.Types.TimepointKind)input.ReadEnum();
            break;
          }
        case 18:
          {
            ContainerId = input.ReadString();
            break;
          }
      }
    }
  }

  #region Nested types
  /// <summary>Container for nested types declared in the Timepoint message type.</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static partial class Types
  {
    public enum TimepointKind
    {
      /// <summary>
      /// Global start of the planning problem. This is context independent and represents the time at which the initial state holds.
      /// </summary>
      [pbr::OriginalName("GLOBAL_START")] GlobalStart = 0,
      /// <summary>
      /// Global end of the planning problem. This is context independent and represents the time at which the final state holds.
      /// </summary>
      [pbr::OriginalName("GLOBAL_END")] GlobalEnd = 1,
      /// <summary>
      /// Start of the container (typically the action or method) in which this symbol occurs
      /// </summary>
      [pbr::OriginalName("START")] Start = 2,
      /// <summary>
      /// End of the container (typically the action or method) in which this symbol occurs
      /// </summary>
      [pbr::OriginalName("END")] End = 3,
    }

  }
  #endregion

}

/// <summary>
/// Represents a time (`timepoint` + `delay`), that is a time defined relatively to a particular `timepoint`.
/// Note that an absolute time can be defined by setting the `delay` relative to the `GLOBAL_START`` which is the reference time.
/// </summary>
public sealed partial class Timing : pb::IMessage<Timing>
{
  private static readonly pb::MessageParser<Timing> _parser = new pb::MessageParser<Timing>(() => new Timing());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Timing> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[12]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Timing()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Timing(Timing other) : this()
  {
    timepoint_ = other.timepoint_ != null ? other.timepoint_.Clone() : null;
    delay_ = other.delay_ != null ? other.delay_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Timing Clone()
  {
    return new Timing(this);
  }

  /// <summary>Field number for the "timepoint" field.</summary>
  public const int TimepointFieldNumber = 1;
  private global::Timepoint timepoint_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Timepoint Timepoint
  {
    get { return timepoint_; }
    set
    {
      timepoint_ = value;
    }
  }

  /// <summary>Field number for the "delay" field.</summary>
  public const int DelayFieldNumber = 2;
  private global::Real delay_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Real Delay
  {
    get { return delay_; }
    set
    {
      delay_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Timing);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Timing other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Timepoint, other.Timepoint)) return false;
    if (!object.Equals(Delay, other.Delay)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (timepoint_ != null) hash ^= Timepoint.GetHashCode();
    if (delay_ != null) hash ^= Delay.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (timepoint_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Timepoint);
    }
    if (delay_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Delay);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (timepoint_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timepoint);
    }
    if (delay_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Delay);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Timing other)
  {
    if (other == null)
    {
      return;
    }
    if (other.timepoint_ != null)
    {
      if (timepoint_ == null)
      {
        timepoint_ = new global::Timepoint();
      }
      Timepoint.MergeFrom(other.Timepoint);
    }
    if (other.delay_ != null)
    {
      if (delay_ == null)
      {
        delay_ = new global::Real();
      }
      Delay.MergeFrom(other.Delay);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (timepoint_ == null)
            {
              timepoint_ = new global::Timepoint();
            }
            input.ReadMessage(timepoint_);
            break;
          }
        case 18:
          {
            if (delay_ == null)
            {
              delay_ = new global::Real();
            }
            input.ReadMessage(delay_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// An interval `[lower, upper]` where `lower` and `upper` are arbitrary expressions.
/// The `is_left_open` and `is_right_open` fields indicate whether the interval is
/// opened on left and right side respectively.
/// </summary>
public sealed partial class Interval : pb::IMessage<Interval>
{
  private static readonly pb::MessageParser<Interval> _parser = new pb::MessageParser<Interval>(() => new Interval());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Interval> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[13]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Interval()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Interval(Interval other) : this()
  {
    isLeftOpen_ = other.isLeftOpen_;
    lower_ = other.lower_ != null ? other.lower_.Clone() : null;
    isRightOpen_ = other.isRightOpen_;
    upper_ = other.upper_ != null ? other.upper_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Interval Clone()
  {
    return new Interval(this);
  }

  /// <summary>Field number for the "is_left_open" field.</summary>
  public const int IsLeftOpenFieldNumber = 1;
  private bool isLeftOpen_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool IsLeftOpen
  {
    get { return isLeftOpen_; }
    set
    {
      isLeftOpen_ = value;
    }
  }

  /// <summary>Field number for the "lower" field.</summary>
  public const int LowerFieldNumber = 2;
  private global::Expression lower_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Lower
  {
    get { return lower_; }
    set
    {
      lower_ = value;
    }
  }

  /// <summary>Field number for the "is_right_open" field.</summary>
  public const int IsRightOpenFieldNumber = 3;
  private bool isRightOpen_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool IsRightOpen
  {
    get { return isRightOpen_; }
    set
    {
      isRightOpen_ = value;
    }
  }

  /// <summary>Field number for the "upper" field.</summary>
  public const int UpperFieldNumber = 4;
  private global::Expression upper_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Upper
  {
    get { return upper_; }
    set
    {
      upper_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Interval);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Interval other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (IsLeftOpen != other.IsLeftOpen) return false;
    if (!object.Equals(Lower, other.Lower)) return false;
    if (IsRightOpen != other.IsRightOpen) return false;
    if (!object.Equals(Upper, other.Upper)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (IsLeftOpen != false) hash ^= IsLeftOpen.GetHashCode();
    if (lower_ != null) hash ^= Lower.GetHashCode();
    if (IsRightOpen != false) hash ^= IsRightOpen.GetHashCode();
    if (upper_ != null) hash ^= Upper.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (IsLeftOpen != false)
    {
      output.WriteRawTag(8);
      output.WriteBool(IsLeftOpen);
    }
    if (lower_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Lower);
    }
    if (IsRightOpen != false)
    {
      output.WriteRawTag(24);
      output.WriteBool(IsRightOpen);
    }
    if (upper_ != null)
    {
      output.WriteRawTag(34);
      output.WriteMessage(Upper);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (IsLeftOpen != false)
    {
      size += 1 + 1;
    }
    if (lower_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lower);
    }
    if (IsRightOpen != false)
    {
      size += 1 + 1;
    }
    if (upper_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Upper);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Interval other)
  {
    if (other == null)
    {
      return;
    }
    if (other.IsLeftOpen != false)
    {
      IsLeftOpen = other.IsLeftOpen;
    }
    if (other.lower_ != null)
    {
      if (lower_ == null)
      {
        lower_ = new global::Expression();
      }
      Lower.MergeFrom(other.Lower);
    }
    if (other.IsRightOpen != false)
    {
      IsRightOpen = other.IsRightOpen;
    }
    if (other.upper_ != null)
    {
      if (upper_ == null)
      {
        upper_ = new global::Expression();
      }
      Upper.MergeFrom(other.Upper);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            IsLeftOpen = input.ReadBool();
            break;
          }
        case 18:
          {
            if (lower_ == null)
            {
              lower_ = new global::Expression();
            }
            input.ReadMessage(lower_);
            break;
          }
        case 24:
          {
            IsRightOpen = input.ReadBool();
            break;
          }
        case 34:
          {
            if (upper_ == null)
            {
              upper_ = new global::Expression();
            }
            input.ReadMessage(upper_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// A contiguous slice of time represented as an interval `[lower, upper]` where `lower` and `upper` are time references.
/// The `is_left_open` and `is_right_open` fields indicate whether the interval is
/// opened on left and right side respectively.
/// </summary>
public sealed partial class TimeInterval : pb::IMessage<TimeInterval>
{
  private static readonly pb::MessageParser<TimeInterval> _parser = new pb::MessageParser<TimeInterval>(() => new TimeInterval());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<TimeInterval> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[14]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimeInterval()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimeInterval(TimeInterval other) : this()
  {
    isLeftOpen_ = other.isLeftOpen_;
    lower_ = other.lower_ != null ? other.lower_.Clone() : null;
    isRightOpen_ = other.isRightOpen_;
    upper_ = other.upper_ != null ? other.upper_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimeInterval Clone()
  {
    return new TimeInterval(this);
  }

  /// <summary>Field number for the "is_left_open" field.</summary>
  public const int IsLeftOpenFieldNumber = 1;
  private bool isLeftOpen_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool IsLeftOpen
  {
    get { return isLeftOpen_; }
    set
    {
      isLeftOpen_ = value;
    }
  }

  /// <summary>Field number for the "lower" field.</summary>
  public const int LowerFieldNumber = 2;
  private global::Timing lower_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Timing Lower
  {
    get { return lower_; }
    set
    {
      lower_ = value;
    }
  }

  /// <summary>Field number for the "is_right_open" field.</summary>
  public const int IsRightOpenFieldNumber = 3;
  private bool isRightOpen_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool IsRightOpen
  {
    get { return isRightOpen_; }
    set
    {
      isRightOpen_ = value;
    }
  }

  /// <summary>Field number for the "upper" field.</summary>
  public const int UpperFieldNumber = 4;
  private global::Timing upper_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Timing Upper
  {
    get { return upper_; }
    set
    {
      upper_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as TimeInterval);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(TimeInterval other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (IsLeftOpen != other.IsLeftOpen) return false;
    if (!object.Equals(Lower, other.Lower)) return false;
    if (IsRightOpen != other.IsRightOpen) return false;
    if (!object.Equals(Upper, other.Upper)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (IsLeftOpen != false) hash ^= IsLeftOpen.GetHashCode();
    if (lower_ != null) hash ^= Lower.GetHashCode();
    if (IsRightOpen != false) hash ^= IsRightOpen.GetHashCode();
    if (upper_ != null) hash ^= Upper.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (IsLeftOpen != false)
    {
      output.WriteRawTag(8);
      output.WriteBool(IsLeftOpen);
    }
    if (lower_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Lower);
    }
    if (IsRightOpen != false)
    {
      output.WriteRawTag(24);
      output.WriteBool(IsRightOpen);
    }
    if (upper_ != null)
    {
      output.WriteRawTag(34);
      output.WriteMessage(Upper);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (IsLeftOpen != false)
    {
      size += 1 + 1;
    }
    if (lower_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Lower);
    }
    if (IsRightOpen != false)
    {
      size += 1 + 1;
    }
    if (upper_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Upper);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(TimeInterval other)
  {
    if (other == null)
    {
      return;
    }
    if (other.IsLeftOpen != false)
    {
      IsLeftOpen = other.IsLeftOpen;
    }
    if (other.lower_ != null)
    {
      if (lower_ == null)
      {
        lower_ = new global::Timing();
      }
      Lower.MergeFrom(other.Lower);
    }
    if (other.IsRightOpen != false)
    {
      IsRightOpen = other.IsRightOpen;
    }
    if (other.upper_ != null)
    {
      if (upper_ == null)
      {
        upper_ = new global::Timing();
      }
      Upper.MergeFrom(other.Upper);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            IsLeftOpen = input.ReadBool();
            break;
          }
        case 18:
          {
            if (lower_ == null)
            {
              lower_ = new global::Timing();
            }
            input.ReadMessage(lower_);
            break;
          }
        case 24:
          {
            IsRightOpen = input.ReadBool();
            break;
          }
        case 34:
          {
            if (upper_ == null)
            {
              upper_ = new global::Timing();
            }
            input.ReadMessage(upper_);
            break;
          }
      }
    }
  }

}

public sealed partial class Duration : pb::IMessage<Duration>
{
  private static readonly pb::MessageParser<Duration> _parser = new pb::MessageParser<Duration>(() => new Duration());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Duration> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[15]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Duration()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Duration(Duration other) : this()
  {
    controllableInBounds_ = other.controllableInBounds_ != null ? other.controllableInBounds_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Duration Clone()
  {
    return new Duration(this);
  }

  /// <summary>Field number for the "controllable_in_bounds" field.</summary>
  public const int ControllableInBoundsFieldNumber = 1;
  private global::Interval controllableInBounds_;
  /// <summary>
  //// The duration of the action can be freely chosen within the indicated bounds
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Interval ControllableInBounds
  {
    get { return controllableInBounds_; }
    set
    {
      controllableInBounds_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Duration);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Duration other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(ControllableInBounds, other.ControllableInBounds)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (controllableInBounds_ != null) hash ^= ControllableInBounds.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (controllableInBounds_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(ControllableInBounds);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (controllableInBounds_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(ControllableInBounds);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Duration other)
  {
    if (other == null)
    {
      return;
    }
    if (other.controllableInBounds_ != null)
    {
      if (controllableInBounds_ == null)
      {
        controllableInBounds_ = new global::Interval();
      }
      ControllableInBounds.MergeFrom(other.ControllableInBounds);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (controllableInBounds_ == null)
            {
              controllableInBounds_ = new global::Interval();
            }
            input.ReadMessage(controllableInBounds_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Declares an abstract task together with its expected parameters.
///
/// Example: goto(robot: Robot, destination: Location)
/// </summary>
public sealed partial class AbstractTaskDeclaration : pb::IMessage<AbstractTaskDeclaration>
{
  private static readonly pb::MessageParser<AbstractTaskDeclaration> _parser = new pb::MessageParser<AbstractTaskDeclaration>(() => new AbstractTaskDeclaration());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<AbstractTaskDeclaration> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[16]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public AbstractTaskDeclaration()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public AbstractTaskDeclaration(AbstractTaskDeclaration other) : this()
  {
    name_ = other.name_;
    parameters_ = other.parameters_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public AbstractTaskDeclaration Clone()
  {
    return new AbstractTaskDeclaration(this);
  }

  /// <summary>Field number for the "name" field.</summary>
  public const int NameFieldNumber = 1;
  private string name_ = "";
  /// <summary>
  /// Example: "goto"
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Name
  {
    get { return name_; }
    set
    {
      name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parameters" field.</summary>
  public const int ParametersFieldNumber = 2;
  private static readonly pb::FieldCodec<global::Parameter> _repeated_parameters_codec
      = pb::FieldCodec.ForMessage(18, global::Parameter.Parser);
  private readonly pbc::RepeatedField<global::Parameter> parameters_ = new pbc::RepeatedField<global::Parameter>();
  /// <summary>
  /// Example:
  ///  - robot: Robot
  ///  - destination: Location
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Parameter> Parameters
  {
    get { return parameters_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as AbstractTaskDeclaration);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(AbstractTaskDeclaration other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Name != other.Name) return false;
    if (!parameters_.Equals(other.parameters_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    hash ^= parameters_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Name.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    parameters_.WriteTo(output, _repeated_parameters_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Name.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    size += parameters_.CalculateSize(_repeated_parameters_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(AbstractTaskDeclaration other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Name.Length != 0)
    {
      Name = other.Name;
    }
    parameters_.Add(other.parameters_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Name = input.ReadString();
            break;
          }
        case 18:
          {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Representation of an abstract or primitive task that should be achieved,
/// required either in the initial task network or as a subtask of a method.
///
/// Example:  task of sending a `robot` to the KITCHEN
///   - t1: goto(robot, KITCHEN)
/// </summary>
public sealed partial class Task : pb::IMessage<Task>
{
  private static readonly pb::MessageParser<Task> _parser = new pb::MessageParser<Task>(() => new Task());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Task> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[17]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Task()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Task(Task other) : this()
  {
    id_ = other.id_;
    taskName_ = other.taskName_;
    parameters_ = other.parameters_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Task Clone()
  {
    return new Task(this);
  }

  /// <summary>Field number for the "id" field.</summary>
  public const int IdFieldNumber = 1;
  private string id_ = "";
  /// <summary>
  /// Identifier of the task, required to be unique in the method/task-network where the task appears.
  /// The `id` is notably used to refer to the start/end of the task.
  ///
  /// Example: t1
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Id
  {
    get { return id_; }
    set
    {
      id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "task_name" field.</summary>
  public const int TaskNameFieldNumber = 2;
  private string taskName_ = "";
  /// <summary>
  /// Name of the task that should be achieved. It might either
  ///  - an abstract task if the name is the one of a task declared in the problem
  ///  - a primitive task if the name is the one of an action declared in the problem
  ///
  /// Example:
  ///  - "goto" (abstract task)
  ///  - "move" (action / primitive task)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string TaskName
  {
    get { return taskName_; }
    set
    {
      taskName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parameters" field.</summary>
  public const int ParametersFieldNumber = 3;
  private static readonly pb::FieldCodec<global::Expression> _repeated_parameters_codec
      = pb::FieldCodec.ForMessage(26, global::Expression.Parser);
  private readonly pbc::RepeatedField<global::Expression> parameters_ = new pbc::RepeatedField<global::Expression>();
  /// <summary>
  /// Example: (for a "goto" task)
  ///  - robot    (a parameter from an outer scope)
  ///  - KITCHEN  (a constant symbol in the problem)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Expression> Parameters
  {
    get { return parameters_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Task);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Task other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Id != other.Id) return false;
    if (TaskName != other.TaskName) return false;
    if (!parameters_.Equals(other.parameters_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Id.Length != 0) hash ^= Id.GetHashCode();
    if (TaskName.Length != 0) hash ^= TaskName.GetHashCode();
    hash ^= parameters_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Id.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Id);
    }
    if (TaskName.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(TaskName);
    }
    parameters_.WriteTo(output, _repeated_parameters_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Id.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
    }
    if (TaskName.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(TaskName);
    }
    size += parameters_.CalculateSize(_repeated_parameters_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Task other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Id.Length != 0)
    {
      Id = other.Id;
    }
    if (other.TaskName.Length != 0)
    {
      TaskName = other.TaskName;
    }
    parameters_.Add(other.parameters_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Id = input.ReadString();
            break;
          }
        case 18:
          {
            TaskName = input.ReadString();
            break;
          }
        case 26:
          {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
      }
    }
  }

}

/// <summary>
/// A method describes one possible way of achieving a task.
///
/// Example: A method that make a "move" action and recursively calls itself until reaching the destination.
/// </summary>
public sealed partial class Method : pb::IMessage<Method>
{
  private static readonly pb::MessageParser<Method> _parser = new pb::MessageParser<Method>(() => new Method());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Method> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[18]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Method()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Method(Method other) : this()
  {
    name_ = other.name_;
    parameters_ = other.parameters_.Clone();
    achievedTask_ = other.achievedTask_ != null ? other.achievedTask_.Clone() : null;
    subtasks_ = other.subtasks_.Clone();
    constraints_ = other.constraints_.Clone();
    conditions_ = other.conditions_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Method Clone()
  {
    return new Method(this);
  }

  /// <summary>Field number for the "name" field.</summary>
  public const int NameFieldNumber = 1;
  private string name_ = "";
  /// <summary>
  /// A name that uniquely identify the method.
  /// This is mostly used for user facing output or plan validation.
  ///
  /// Example: "m-recursive-goto"
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Name
  {
    get { return name_; }
    set
    {
      name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parameters" field.</summary>
  public const int ParametersFieldNumber = 2;
  private static readonly pb::FieldCodec<global::Parameter> _repeated_parameters_codec
      = pb::FieldCodec.ForMessage(18, global::Parameter.Parser);
  private readonly pbc::RepeatedField<global::Parameter> parameters_ = new pbc::RepeatedField<global::Parameter>();
  /// <summary>
  /// Example: [robot: Robot, source: Location, intermediate: Location, destination: Location]
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Parameter> Parameters
  {
    get { return parameters_; }
  }

  /// <summary>Field number for the "achieved_task" field.</summary>
  public const int AchievedTaskFieldNumber = 3;
  private global::Task achievedTask_;
  /// <summary>
  /// The task that is achieved by the method.
  /// A subset of the parameters of the method will typically be used to
  /// define the task that is achieved.
  ///
  /// Example: goto(robot, destination)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Task AchievedTask
  {
    get { return achievedTask_; }
    set
    {
      achievedTask_ = value;
    }
  }

  /// <summary>Field number for the "subtasks" field.</summary>
  public const int SubtasksFieldNumber = 4;
  private static readonly pb::FieldCodec<global::Task> _repeated_subtasks_codec
      = pb::FieldCodec.ForMessage(34, global::Task.Parser);
  private readonly pbc::RepeatedField<global::Task> subtasks_ = new pbc::RepeatedField<global::Task>();
  /// <summary>
  /// A set of subtasks that should be achieved to carry out the method.
  /// Note that the order of subtasks is irrelevant and that any ordering constraint should be
  /// specified in the `constraints` field.
  ///
  /// Example:
  ///  - t1: (move robot source intermediate)
  ///  - t2: goto(robot destination)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Task> Subtasks
  {
    get { return subtasks_; }
  }

  /// <summary>Field number for the "constraints" field.</summary>
  public const int ConstraintsFieldNumber = 5;
  private static readonly pb::FieldCodec<global::Expression> _repeated_constraints_codec
      = pb::FieldCodec.ForMessage(42, global::Expression.Parser);
  private readonly pbc::RepeatedField<global::Expression> constraints_ = new pbc::RepeatedField<global::Expression>();
  /// <summary>
  /// Constraints enable the definition of ordering constraints as well as constraints
  /// on the allowed instantiation of the method's parameters.
  ///
  /// Example:
  ///  - end(t1) &lt; start(t2)
  ///  - source != intermediate
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Expression> Constraints
  {
    get { return constraints_; }
  }

  /// <summary>Field number for the "conditions" field.</summary>
  public const int ConditionsFieldNumber = 6;
  private static readonly pb::FieldCodec<global::Condition> _repeated_conditions_codec
      = pb::FieldCodec.ForMessage(50, global::Condition.Parser);
  private readonly pbc::RepeatedField<global::Condition> conditions_ = new pbc::RepeatedField<global::Condition>();
  /// <summary>
  /// Conjunction of conditions that must hold for the method to be applicable.
  /// As for the conditions of actions, these can be temporally qualified to refer to intermediate timepoints.
  /// In addition to the start/end of the method, the temporal qualification might refer to the start/end of
  /// one of the subtasks using its identifier.
  ///
  /// Example:
  ///  - [start] loc(robot) == source
  ///  - [end(t1)] loc(robot) == intermediate
  ///  - [end] loc(robot) == destination
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Condition> Conditions
  {
    get { return conditions_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Method);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Method other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Name != other.Name) return false;
    if (!parameters_.Equals(other.parameters_)) return false;
    if (!object.Equals(AchievedTask, other.AchievedTask)) return false;
    if (!subtasks_.Equals(other.subtasks_)) return false;
    if (!constraints_.Equals(other.constraints_)) return false;
    if (!conditions_.Equals(other.conditions_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    hash ^= parameters_.GetHashCode();
    if (achievedTask_ != null) hash ^= AchievedTask.GetHashCode();
    hash ^= subtasks_.GetHashCode();
    hash ^= constraints_.GetHashCode();
    hash ^= conditions_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Name.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    parameters_.WriteTo(output, _repeated_parameters_codec);
    if (achievedTask_ != null)
    {
      output.WriteRawTag(26);
      output.WriteMessage(AchievedTask);
    }
    subtasks_.WriteTo(output, _repeated_subtasks_codec);
    constraints_.WriteTo(output, _repeated_constraints_codec);
    conditions_.WriteTo(output, _repeated_conditions_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Name.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    size += parameters_.CalculateSize(_repeated_parameters_codec);
    if (achievedTask_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(AchievedTask);
    }
    size += subtasks_.CalculateSize(_repeated_subtasks_codec);
    size += constraints_.CalculateSize(_repeated_constraints_codec);
    size += conditions_.CalculateSize(_repeated_conditions_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Method other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Name.Length != 0)
    {
      Name = other.Name;
    }
    parameters_.Add(other.parameters_);
    if (other.achievedTask_ != null)
    {
      if (achievedTask_ == null)
      {
        achievedTask_ = new global::Task();
      }
      AchievedTask.MergeFrom(other.AchievedTask);
    }
    subtasks_.Add(other.subtasks_);
    constraints_.Add(other.constraints_);
    conditions_.Add(other.conditions_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Name = input.ReadString();
            break;
          }
        case 18:
          {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
        case 26:
          {
            if (achievedTask_ == null)
            {
              achievedTask_ = new global::Task();
            }
            input.ReadMessage(achievedTask_);
            break;
          }
        case 34:
          {
            subtasks_.AddEntriesFrom(input, _repeated_subtasks_codec);
            break;
          }
        case 42:
          {
            constraints_.AddEntriesFrom(input, _repeated_constraints_codec);
            break;
          }
        case 50:
          {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
      }
    }
  }

}

/// <summary>
/// A task network defines a set of subtasks and associated constraints.
/// It is intended to be used to define the initial task network of the hierarchical problem.
///
/// Example: an arbitrary robot should go to the KITCHEN before time 100
/// </summary>
public sealed partial class TaskNetwork : pb::IMessage<TaskNetwork>
{
  private static readonly pb::MessageParser<TaskNetwork> _parser = new pb::MessageParser<TaskNetwork>(() => new TaskNetwork());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<TaskNetwork> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[19]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TaskNetwork()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TaskNetwork(TaskNetwork other) : this()
  {
    variables_ = other.variables_.Clone();
    subtasks_ = other.subtasks_.Clone();
    constraints_ = other.constraints_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TaskNetwork Clone()
  {
    return new TaskNetwork(this);
  }

  /// <summary>Field number for the "variables" field.</summary>
  public const int VariablesFieldNumber = 1;
  private static readonly pb::FieldCodec<global::Parameter> _repeated_variables_codec
      = pb::FieldCodec.ForMessage(10, global::Parameter.Parser);
  private readonly pbc::RepeatedField<global::Parameter> variables_ = new pbc::RepeatedField<global::Parameter>();
  /// <summary>
  /// robot: Location
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Parameter> Variables
  {
    get { return variables_; }
  }

  /// <summary>Field number for the "subtasks" field.</summary>
  public const int SubtasksFieldNumber = 2;
  private static readonly pb::FieldCodec<global::Task> _repeated_subtasks_codec
      = pb::FieldCodec.ForMessage(18, global::Task.Parser);
  private readonly pbc::RepeatedField<global::Task> subtasks_ = new pbc::RepeatedField<global::Task>();
  /// <summary>
  /// t1: goto(robot, KITCHEN)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Task> Subtasks
  {
    get { return subtasks_; }
  }

  /// <summary>Field number for the "constraints" field.</summary>
  public const int ConstraintsFieldNumber = 3;
  private static readonly pb::FieldCodec<global::Expression> _repeated_constraints_codec
      = pb::FieldCodec.ForMessage(26, global::Expression.Parser);
  private readonly pbc::RepeatedField<global::Expression> constraints_ = new pbc::RepeatedField<global::Expression>();
  /// <summary>
  /// end(t1) &lt;= 100
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Expression> Constraints
  {
    get { return constraints_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as TaskNetwork);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(TaskNetwork other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!variables_.Equals(other.variables_)) return false;
    if (!subtasks_.Equals(other.subtasks_)) return false;
    if (!constraints_.Equals(other.constraints_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    hash ^= variables_.GetHashCode();
    hash ^= subtasks_.GetHashCode();
    hash ^= constraints_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    variables_.WriteTo(output, _repeated_variables_codec);
    subtasks_.WriteTo(output, _repeated_subtasks_codec);
    constraints_.WriteTo(output, _repeated_constraints_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    size += variables_.CalculateSize(_repeated_variables_codec);
    size += subtasks_.CalculateSize(_repeated_subtasks_codec);
    size += constraints_.CalculateSize(_repeated_constraints_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(TaskNetwork other)
  {
    if (other == null)
    {
      return;
    }
    variables_.Add(other.variables_);
    subtasks_.Add(other.subtasks_);
    constraints_.Add(other.constraints_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            variables_.AddEntriesFrom(input, _repeated_variables_codec);
            break;
          }
        case 18:
          {
            subtasks_.AddEntriesFrom(input, _repeated_subtasks_codec);
            break;
          }
        case 26:
          {
            constraints_.AddEntriesFrom(input, _repeated_constraints_codec);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Represents the hierarchical part of a problem.
/// features: hierarchical
/// </summary>
public sealed partial class Hierarchy : pb::IMessage<Hierarchy>
{
  private static readonly pb::MessageParser<Hierarchy> _parser = new pb::MessageParser<Hierarchy>(() => new Hierarchy());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Hierarchy> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[20]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Hierarchy()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Hierarchy(Hierarchy other) : this()
  {
    abstractTasks_ = other.abstractTasks_.Clone();
    methods_ = other.methods_.Clone();
    initialTaskNetwork_ = other.initialTaskNetwork_ != null ? other.initialTaskNetwork_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Hierarchy Clone()
  {
    return new Hierarchy(this);
  }

  /// <summary>Field number for the "abstract_tasks" field.</summary>
  public const int AbstractTasksFieldNumber = 1;
  private static readonly pb::FieldCodec<global::AbstractTaskDeclaration> _repeated_abstractTasks_codec
      = pb::FieldCodec.ForMessage(10, global::AbstractTaskDeclaration.Parser);
  private readonly pbc::RepeatedField<global::AbstractTaskDeclaration> abstractTasks_ = new pbc::RepeatedField<global::AbstractTaskDeclaration>();
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::AbstractTaskDeclaration> AbstractTasks
  {
    get { return abstractTasks_; }
  }

  /// <summary>Field number for the "methods" field.</summary>
  public const int MethodsFieldNumber = 2;
  private static readonly pb::FieldCodec<global::Method> _repeated_methods_codec
      = pb::FieldCodec.ForMessage(18, global::Method.Parser);
  private readonly pbc::RepeatedField<global::Method> methods_ = new pbc::RepeatedField<global::Method>();
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Method> Methods
  {
    get { return methods_; }
  }

  /// <summary>Field number for the "initial_task_network" field.</summary>
  public const int InitialTaskNetworkFieldNumber = 3;
  private global::TaskNetwork initialTaskNetwork_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::TaskNetwork InitialTaskNetwork
  {
    get { return initialTaskNetwork_; }
    set
    {
      initialTaskNetwork_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Hierarchy);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Hierarchy other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!abstractTasks_.Equals(other.abstractTasks_)) return false;
    if (!methods_.Equals(other.methods_)) return false;
    if (!object.Equals(InitialTaskNetwork, other.InitialTaskNetwork)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    hash ^= abstractTasks_.GetHashCode();
    hash ^= methods_.GetHashCode();
    if (initialTaskNetwork_ != null) hash ^= InitialTaskNetwork.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    abstractTasks_.WriteTo(output, _repeated_abstractTasks_codec);
    methods_.WriteTo(output, _repeated_methods_codec);
    if (initialTaskNetwork_ != null)
    {
      output.WriteRawTag(26);
      output.WriteMessage(InitialTaskNetwork);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    size += abstractTasks_.CalculateSize(_repeated_abstractTasks_codec);
    size += methods_.CalculateSize(_repeated_methods_codec);
    if (initialTaskNetwork_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(InitialTaskNetwork);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Hierarchy other)
  {
    if (other == null)
    {
      return;
    }
    abstractTasks_.Add(other.abstractTasks_);
    methods_.Add(other.methods_);
    if (other.initialTaskNetwork_ != null)
    {
      if (initialTaskNetwork_ == null)
      {
        initialTaskNetwork_ = new global::TaskNetwork();
      }
      InitialTaskNetwork.MergeFrom(other.InitialTaskNetwork);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            abstractTasks_.AddEntriesFrom(input, _repeated_abstractTasks_codec);
            break;
          }
        case 18:
          {
            methods_.AddEntriesFrom(input, _repeated_methods_codec);
            break;
          }
        case 26:
          {
            if (initialTaskNetwork_ == null)
            {
              initialTaskNetwork_ = new global::TaskNetwork();
            }
            input.ReadMessage(initialTaskNetwork_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Activity in a scheduling problem.
/// </summary>
public sealed partial class Activity : pb::IMessage<Activity>
{
  private static readonly pb::MessageParser<Activity> _parser = new pb::MessageParser<Activity>(() => new Activity());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Activity> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[21]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Activity()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Activity(Activity other) : this()
  {
    name_ = other.name_;
    parameters_ = other.parameters_.Clone();
    duration_ = other.duration_ != null ? other.duration_.Clone() : null;
    conditions_ = other.conditions_.Clone();
    effects_ = other.effects_.Clone();
    constraints_ = other.constraints_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Activity Clone()
  {
    return new Activity(this);
  }

  /// <summary>Field number for the "name" field.</summary>
  public const int NameFieldNumber = 1;
  private string name_ = "";
  /// <summary>
  /// Name of the activity that must uniquely identify it.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Name
  {
    get { return name_; }
    set
    {
      name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parameters" field.</summary>
  public const int ParametersFieldNumber = 2;
  private static readonly pb::FieldCodec<global::Parameter> _repeated_parameters_codec
      = pb::FieldCodec.ForMessage(18, global::Parameter.Parser);
  private readonly pbc::RepeatedField<global::Parameter> parameters_ = new pbc::RepeatedField<global::Parameter>();
  /// <summary>
  /// Typed and named parameters of the activity.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Parameter> Parameters
  {
    get { return parameters_; }
  }

  /// <summary>Field number for the "duration" field.</summary>
  public const int DurationFieldNumber = 3;
  private global::Duration duration_;
  /// <summary>
  /// Duration of the activity
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Duration Duration
  {
    get { return duration_; }
    set
    {
      duration_ = value;
    }
  }

  /// <summary>Field number for the "conditions" field.</summary>
  public const int ConditionsFieldNumber = 4;
  private static readonly pb::FieldCodec<global::Condition> _repeated_conditions_codec
      = pb::FieldCodec.ForMessage(34, global::Condition.Parser);
  private readonly pbc::RepeatedField<global::Condition> conditions_ = new pbc::RepeatedField<global::Condition>();
  /// <summary>
  /// Conjunction of conditions that must hold if the activity is present.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Condition> Conditions
  {
    get { return conditions_; }
  }

  /// <summary>Field number for the "effects" field.</summary>
  public const int EffectsFieldNumber = 5;
  private static readonly pb::FieldCodec<global::Effect> _repeated_effects_codec
      = pb::FieldCodec.ForMessage(42, global::Effect.Parser);
  private readonly pbc::RepeatedField<global::Effect> effects_ = new pbc::RepeatedField<global::Effect>();
  /// <summary>
  /// Conjunction of effects that this activity produces.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Effect> Effects
  {
    get { return effects_; }
  }

  /// <summary>Field number for the "constraints" field.</summary>
  public const int ConstraintsFieldNumber = 6;
  private static readonly pb::FieldCodec<global::Expression> _repeated_constraints_codec
      = pb::FieldCodec.ForMessage(50, global::Expression.Parser);
  private readonly pbc::RepeatedField<global::Expression> constraints_ = new pbc::RepeatedField<global::Expression>();
  /// <summary>
  /// Conjunction of static constraints that must hold if the activity is present.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Expression> Constraints
  {
    get { return constraints_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Activity);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Activity other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Name != other.Name) return false;
    if (!parameters_.Equals(other.parameters_)) return false;
    if (!object.Equals(Duration, other.Duration)) return false;
    if (!conditions_.Equals(other.conditions_)) return false;
    if (!effects_.Equals(other.effects_)) return false;
    if (!constraints_.Equals(other.constraints_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    hash ^= parameters_.GetHashCode();
    if (duration_ != null) hash ^= Duration.GetHashCode();
    hash ^= conditions_.GetHashCode();
    hash ^= effects_.GetHashCode();
    hash ^= constraints_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Name.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    parameters_.WriteTo(output, _repeated_parameters_codec);
    if (duration_ != null)
    {
      output.WriteRawTag(26);
      output.WriteMessage(Duration);
    }
    conditions_.WriteTo(output, _repeated_conditions_codec);
    effects_.WriteTo(output, _repeated_effects_codec);
    constraints_.WriteTo(output, _repeated_constraints_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Name.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    size += parameters_.CalculateSize(_repeated_parameters_codec);
    if (duration_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Duration);
    }
    size += conditions_.CalculateSize(_repeated_conditions_codec);
    size += effects_.CalculateSize(_repeated_effects_codec);
    size += constraints_.CalculateSize(_repeated_constraints_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Activity other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Name.Length != 0)
    {
      Name = other.Name;
    }
    parameters_.Add(other.parameters_);
    if (other.duration_ != null)
    {
      if (duration_ == null)
      {
        duration_ = new global::Duration();
      }
      Duration.MergeFrom(other.Duration);
    }
    conditions_.Add(other.conditions_);
    effects_.Add(other.effects_);
    constraints_.Add(other.constraints_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Name = input.ReadString();
            break;
          }
        case 18:
          {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
        case 26:
          {
            if (duration_ == null)
            {
              duration_ = new global::Duration();
            }
            input.ReadMessage(duration_);
            break;
          }
        case 34:
          {
            conditions_.AddEntriesFrom(input, _repeated_conditions_codec);
            break;
          }
        case 42:
          {
            effects_.AddEntriesFrom(input, _repeated_effects_codec);
            break;
          }
        case 50:
          {
            constraints_.AddEntriesFrom(input, _repeated_constraints_codec);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Extension of `Problem` for scheduling
/// </summary>
public sealed partial class SchedulingExtension : pb::IMessage<SchedulingExtension>
{
  private static readonly pb::MessageParser<SchedulingExtension> _parser = new pb::MessageParser<SchedulingExtension>(() => new SchedulingExtension());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<SchedulingExtension> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[22]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public SchedulingExtension()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public SchedulingExtension(SchedulingExtension other) : this()
  {
    activities_ = other.activities_.Clone();
    variables_ = other.variables_.Clone();
    constraints_ = other.constraints_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public SchedulingExtension Clone()
  {
    return new SchedulingExtension(this);
  }

  /// <summary>Field number for the "activities" field.</summary>
  public const int ActivitiesFieldNumber = 1;
  private static readonly pb::FieldCodec<global::Activity> _repeated_activities_codec
      = pb::FieldCodec.ForMessage(10, global::Activity.Parser);
  private readonly pbc::RepeatedField<global::Activity> activities_ = new pbc::RepeatedField<global::Activity>();
  /// <summary>
  /// All potential activities of the scheduling problem.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Activity> Activities
  {
    get { return activities_; }
  }

  /// <summary>Field number for the "variables" field.</summary>
  public const int VariablesFieldNumber = 2;
  private static readonly pb::FieldCodec<global::Parameter> _repeated_variables_codec
      = pb::FieldCodec.ForMessage(18, global::Parameter.Parser);
  private readonly pbc::RepeatedField<global::Parameter> variables_ = new pbc::RepeatedField<global::Parameter>();
  /// <summary>
  /// All variables in the base problem
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Parameter> Variables
  {
    get { return variables_; }
  }

  /// <summary>Field number for the "constraints" field.</summary>
  public const int ConstraintsFieldNumber = 5;
  private static readonly pb::FieldCodec<global::Expression> _repeated_constraints_codec
      = pb::FieldCodec.ForMessage(42, global::Expression.Parser);
  private readonly pbc::RepeatedField<global::Expression> constraints_ = new pbc::RepeatedField<global::Expression>();
  /// <summary>
  /// All constraints in the base problem.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Expression> Constraints
  {
    get { return constraints_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as SchedulingExtension);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(SchedulingExtension other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!activities_.Equals(other.activities_)) return false;
    if (!variables_.Equals(other.variables_)) return false;
    if (!constraints_.Equals(other.constraints_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    hash ^= activities_.GetHashCode();
    hash ^= variables_.GetHashCode();
    hash ^= constraints_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    activities_.WriteTo(output, _repeated_activities_codec);
    variables_.WriteTo(output, _repeated_variables_codec);
    constraints_.WriteTo(output, _repeated_constraints_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    size += activities_.CalculateSize(_repeated_activities_codec);
    size += variables_.CalculateSize(_repeated_variables_codec);
    size += constraints_.CalculateSize(_repeated_constraints_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(SchedulingExtension other)
  {
    if (other == null)
    {
      return;
    }
    activities_.Add(other.activities_);
    variables_.Add(other.variables_);
    constraints_.Add(other.constraints_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            activities_.AddEntriesFrom(input, _repeated_activities_codec);
            break;
          }
        case 18:
          {
            variables_.AddEntriesFrom(input, _repeated_variables_codec);
            break;
          }
        case 42:
          {
            constraints_.AddEntriesFrom(input, _repeated_constraints_codec);
            break;
          }
      }
    }
  }

}

public sealed partial class Schedule : pb::IMessage<Schedule>
{
  private static readonly pb::MessageParser<Schedule> _parser = new pb::MessageParser<Schedule>(() => new Schedule());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Schedule> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[23]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Schedule()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Schedule(Schedule other) : this()
  {
    activities_ = other.activities_.Clone();
    variableAssignments_ = other.variableAssignments_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Schedule Clone()
  {
    return new Schedule(this);
  }

  /// <summary>Field number for the "activities" field.</summary>
  public const int ActivitiesFieldNumber = 1;
  private static readonly pb::FieldCodec<string> _repeated_activities_codec
      = pb::FieldCodec.ForString(10);
  private readonly pbc::RepeatedField<string> activities_ = new pbc::RepeatedField<string>();
  /// <summary>
  /// Name of the activities that appear in the solution
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<string> Activities
  {
    get { return activities_; }
  }

  /// <summary>Field number for the "variable_assignments" field.</summary>
  public const int VariableAssignmentsFieldNumber = 2;
  private static readonly pbc::MapField<string, global::Atom>.Codec _map_variableAssignments_codec
      = new pbc::MapField<string, global::Atom>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Atom.Parser), 18);
  private readonly pbc::MapField<string, global::Atom> variableAssignments_ = new pbc::MapField<string, global::Atom>();
  /// <summary>
  /// Assignment of all variables and activity parameters and timepoints
  /// that appear in the solution.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::MapField<string, global::Atom> VariableAssignments
  {
    get { return variableAssignments_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Schedule);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Schedule other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!activities_.Equals(other.activities_)) return false;
    if (!VariableAssignments.Equals(other.VariableAssignments)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    hash ^= activities_.GetHashCode();
    hash ^= VariableAssignments.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    activities_.WriteTo(output, _repeated_activities_codec);
    variableAssignments_.WriteTo(output, _map_variableAssignments_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    size += activities_.CalculateSize(_repeated_activities_codec);
    size += variableAssignments_.CalculateSize(_map_variableAssignments_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Schedule other)
  {
    if (other == null)
    {
      return;
    }
    activities_.Add(other.activities_);
    variableAssignments_.Add(other.variableAssignments_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            activities_.AddEntriesFrom(input, _repeated_activities_codec);
            break;
          }
        case 18:
          {
            variableAssignments_.AddEntriesFrom(input, _map_variableAssignments_codec);
            break;
          }
      }
    }
  }

}

/// <summary>
/// A Goal is currently an expression that must hold either:
/// - in the final state,
/// - over a specific temporal interval (under the `timed_goals` features)
/// </summary>
public sealed partial class Goal : pb::IMessage<Goal>
{
  private static readonly pb::MessageParser<Goal> _parser = new pb::MessageParser<Goal>(() => new Goal());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Goal> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[24]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Goal()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Goal(Goal other) : this()
  {
    goal_ = other.goal_ != null ? other.goal_.Clone() : null;
    timing_ = other.timing_ != null ? other.timing_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Goal Clone()
  {
    return new Goal(this);
  }

  /// <summary>Field number for the "goal" field.</summary>
  public const int Goal_FieldNumber = 1;
  private global::Expression goal_;
  /// <summary>
  /// Goal expression that must hold in the final state.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Goal_
  {
    get { return goal_; }
    set
    {
      goal_ = value;
    }
  }

  /// <summary>Field number for the "timing" field.</summary>
  public const int TimingFieldNumber = 2;
  private global::TimeInterval timing_;
  /// <summary>
  /// Optional. If specified the goal should hold over the specified temporal interval (instead of on the final state).
  /// features: TIMED_GOALS
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::TimeInterval Timing
  {
    get { return timing_; }
    set
    {
      timing_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Goal);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Goal other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Goal_, other.Goal_)) return false;
    if (!object.Equals(Timing, other.Timing)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (goal_ != null) hash ^= Goal_.GetHashCode();
    if (timing_ != null) hash ^= Timing.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (goal_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Goal_);
    }
    if (timing_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Timing);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (goal_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Goal_);
    }
    if (timing_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timing);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Goal other)
  {
    if (other == null)
    {
      return;
    }
    if (other.goal_ != null)
    {
      if (goal_ == null)
      {
        goal_ = new global::Expression();
      }
      Goal_.MergeFrom(other.Goal_);
    }
    if (other.timing_ != null)
    {
      if (timing_ == null)
      {
        timing_ = new global::TimeInterval();
      }
      Timing.MergeFrom(other.Timing);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (goal_ == null)
            {
              goal_ = new global::Expression();
            }
            input.ReadMessage(goal_);
            break;
          }
        case 18:
          {
            if (timing_ == null)
            {
              timing_ = new global::TimeInterval();
            }
            input.ReadMessage(timing_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Represents an effect that will occur sometime beyond the initial state. (similar to timed initial literals)
/// </summary>
public sealed partial class TimedEffect : pb::IMessage<TimedEffect>
{
  private static readonly pb::MessageParser<TimedEffect> _parser = new pb::MessageParser<TimedEffect>(() => new TimedEffect());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<TimedEffect> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[25]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimedEffect()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimedEffect(TimedEffect other) : this()
  {
    effect_ = other.effect_ != null ? other.effect_.Clone() : null;
    occurrenceTime_ = other.occurrenceTime_ != null ? other.occurrenceTime_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimedEffect Clone()
  {
    return new TimedEffect(this);
  }

  /// <summary>Field number for the "effect" field.</summary>
  public const int EffectFieldNumber = 1;
  private global::EffectExpression effect_;
  /// <summary>
  /// Required. An effect expression that will take place sometime in the future (i.e. not at the intial state) as specified by the temporal qualifiation.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::EffectExpression Effect
  {
    get { return effect_; }
    set
    {
      effect_ = value;
    }
  }

  /// <summary>Field number for the "occurrence_time" field.</summary>
  public const int OccurrenceTimeFieldNumber = 2;
  private global::Timing occurrenceTime_;
  /// <summary>
  /// Required. Temporal qualification denoting when the timed fact will occur.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Timing OccurrenceTime
  {
    get { return occurrenceTime_; }
    set
    {
      occurrenceTime_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as TimedEffect);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(TimedEffect other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Effect, other.Effect)) return false;
    if (!object.Equals(OccurrenceTime, other.OccurrenceTime)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (effect_ != null) hash ^= Effect.GetHashCode();
    if (occurrenceTime_ != null) hash ^= OccurrenceTime.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (effect_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Effect);
    }
    if (occurrenceTime_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(OccurrenceTime);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (effect_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Effect);
    }
    if (occurrenceTime_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(OccurrenceTime);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(TimedEffect other)
  {
    if (other == null)
    {
      return;
    }
    if (other.effect_ != null)
    {
      if (effect_ == null)
      {
        effect_ = new global::EffectExpression();
      }
      Effect.MergeFrom(other.Effect);
    }
    if (other.occurrenceTime_ != null)
    {
      if (occurrenceTime_ == null)
      {
        occurrenceTime_ = new global::Timing();
      }
      OccurrenceTime.MergeFrom(other.OccurrenceTime);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (effect_ == null)
            {
              effect_ = new global::EffectExpression();
            }
            input.ReadMessage(effect_);
            break;
          }
        case 18:
          {
            if (occurrenceTime_ == null)
            {
              occurrenceTime_ = new global::Timing();
            }
            input.ReadMessage(occurrenceTime_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// An assignment of a value to a fluent, as it appears in the initial state definition.
/// </summary>
public sealed partial class Assignment : pb::IMessage<Assignment>
{
  private static readonly pb::MessageParser<Assignment> _parser = new pb::MessageParser<Assignment>(() => new Assignment());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Assignment> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[26]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Assignment()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Assignment(Assignment other) : this()
  {
    fluent_ = other.fluent_ != null ? other.fluent_.Clone() : null;
    value_ = other.value_ != null ? other.value_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Assignment Clone()
  {
    return new Assignment(this);
  }

  /// <summary>Field number for the "fluent" field.</summary>
  public const int FluentFieldNumber = 1;
  private global::Expression fluent_;
  /// <summary>
  /// State variable that is assigned the `value`.
  /// It should be an expression of the STATE_VARIABLE kind for which all parameters are of the CONSTANT kind.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Fluent
  {
    get { return fluent_; }
    set
    {
      fluent_ = value;
    }
  }

  /// <summary>Field number for the "value" field.</summary>
  public const int ValueFieldNumber = 2;
  private global::Expression value_;
  /// <summary>
  /// An expression of the CONSTANT kind, denoting the value take by the state variable.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Value
  {
    get { return value_; }
    set
    {
      value_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Assignment);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Assignment other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Fluent, other.Fluent)) return false;
    if (!object.Equals(Value, other.Value)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (fluent_ != null) hash ^= Fluent.GetHashCode();
    if (value_ != null) hash ^= Value.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (fluent_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Fluent);
    }
    if (value_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Value);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (fluent_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Fluent);
    }
    if (value_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Value);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Assignment other)
  {
    if (other == null)
    {
      return;
    }
    if (other.fluent_ != null)
    {
      if (fluent_ == null)
      {
        fluent_ = new global::Expression();
      }
      Fluent.MergeFrom(other.Fluent);
    }
    if (other.value_ != null)
    {
      if (value_ == null)
      {
        value_ = new global::Expression();
      }
      Value.MergeFrom(other.Value);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (fluent_ == null)
            {
              fluent_ = new global::Expression();
            }
            input.ReadMessage(fluent_);
            break;
          }
        case 18:
          {
            if (value_ == null)
            {
              value_ = new global::Expression();
            }
            input.ReadMessage(value_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Represents a goal associated with a weight, used to define oversubscription planning.
/// </summary>
public sealed partial class GoalWithWeight : pb::IMessage<GoalWithWeight>
{
  private static readonly pb::MessageParser<GoalWithWeight> _parser = new pb::MessageParser<GoalWithWeight>(() => new GoalWithWeight());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<GoalWithWeight> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[27]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public GoalWithWeight()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public GoalWithWeight(GoalWithWeight other) : this()
  {
    goal_ = other.goal_ != null ? other.goal_.Clone() : null;
    weight_ = other.weight_ != null ? other.weight_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public GoalWithWeight Clone()
  {
    return new GoalWithWeight(this);
  }

  /// <summary>Field number for the "goal" field.</summary>
  public const int GoalFieldNumber = 1;
  private global::Expression goal_;
  /// <summary>
  /// Goal expression
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Goal
  {
    get { return goal_; }
    set
    {
      goal_ = value;
    }
  }

  /// <summary>Field number for the "weight" field.</summary>
  public const int WeightFieldNumber = 2;
  private global::Real weight_;
  /// <summary>
  /// The weight
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Real Weight
  {
    get { return weight_; }
    set
    {
      weight_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as GoalWithWeight);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(GoalWithWeight other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Goal, other.Goal)) return false;
    if (!object.Equals(Weight, other.Weight)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (goal_ != null) hash ^= Goal.GetHashCode();
    if (weight_ != null) hash ^= Weight.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (goal_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Goal);
    }
    if (weight_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Weight);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (goal_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Goal);
    }
    if (weight_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Weight);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(GoalWithWeight other)
  {
    if (other == null)
    {
      return;
    }
    if (other.goal_ != null)
    {
      if (goal_ == null)
      {
        goal_ = new global::Expression();
      }
      Goal.MergeFrom(other.Goal);
    }
    if (other.weight_ != null)
    {
      if (weight_ == null)
      {
        weight_ = new global::Real();
      }
      Weight.MergeFrom(other.Weight);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (goal_ == null)
            {
              goal_ = new global::Expression();
            }
            input.ReadMessage(goal_);
            break;
          }
        case 18:
          {
            if (weight_ == null)
            {
              weight_ = new global::Real();
            }
            input.ReadMessage(weight_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Represents a timed goal associated with a weight, used to define temporal oversubscription planning.
/// </summary>
public sealed partial class TimedGoalWithWeight : pb::IMessage<TimedGoalWithWeight>
{
  private static readonly pb::MessageParser<TimedGoalWithWeight> _parser = new pb::MessageParser<TimedGoalWithWeight>(() => new TimedGoalWithWeight());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<TimedGoalWithWeight> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[28]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimedGoalWithWeight()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimedGoalWithWeight(TimedGoalWithWeight other) : this()
  {
    goal_ = other.goal_ != null ? other.goal_.Clone() : null;
    timing_ = other.timing_ != null ? other.timing_.Clone() : null;
    weight_ = other.weight_ != null ? other.weight_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public TimedGoalWithWeight Clone()
  {
    return new TimedGoalWithWeight(this);
  }

  /// <summary>Field number for the "goal" field.</summary>
  public const int GoalFieldNumber = 1;
  private global::Expression goal_;
  /// <summary>
  /// Goal expression
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Goal
  {
    get { return goal_; }
    set
    {
      goal_ = value;
    }
  }

  /// <summary>Field number for the "timing" field.</summary>
  public const int TimingFieldNumber = 2;
  private global::TimeInterval timing_;
  /// <summary>
  /// The time interval
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::TimeInterval Timing
  {
    get { return timing_; }
    set
    {
      timing_ = value;
    }
  }

  /// <summary>Field number for the "weight" field.</summary>
  public const int WeightFieldNumber = 3;
  private global::Real weight_;
  /// <summary>
  /// The weight
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Real Weight
  {
    get { return weight_; }
    set
    {
      weight_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as TimedGoalWithWeight);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(TimedGoalWithWeight other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Goal, other.Goal)) return false;
    if (!object.Equals(Timing, other.Timing)) return false;
    if (!object.Equals(Weight, other.Weight)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (goal_ != null) hash ^= Goal.GetHashCode();
    if (timing_ != null) hash ^= Timing.GetHashCode();
    if (weight_ != null) hash ^= Weight.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (goal_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Goal);
    }
    if (timing_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Timing);
    }
    if (weight_ != null)
    {
      output.WriteRawTag(26);
      output.WriteMessage(Weight);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (goal_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Goal);
    }
    if (timing_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Timing);
    }
    if (weight_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Weight);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(TimedGoalWithWeight other)
  {
    if (other == null)
    {
      return;
    }
    if (other.goal_ != null)
    {
      if (goal_ == null)
      {
        goal_ = new global::Expression();
      }
      Goal.MergeFrom(other.Goal);
    }
    if (other.timing_ != null)
    {
      if (timing_ == null)
      {
        timing_ = new global::TimeInterval();
      }
      Timing.MergeFrom(other.Timing);
    }
    if (other.weight_ != null)
    {
      if (weight_ == null)
      {
        weight_ = new global::Real();
      }
      Weight.MergeFrom(other.Weight);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (goal_ == null)
            {
              goal_ = new global::Expression();
            }
            input.ReadMessage(goal_);
            break;
          }
        case 18:
          {
            if (timing_ == null)
            {
              timing_ = new global::TimeInterval();
            }
            input.ReadMessage(timing_);
            break;
          }
        case 26:
          {
            if (weight_ == null)
            {
              weight_ = new global::Real();
            }
            input.ReadMessage(weight_);
            break;
          }
      }
    }
  }

}

public sealed partial class Metric : pb::IMessage<Metric>
{
  private static readonly pb::MessageParser<Metric> _parser = new pb::MessageParser<Metric>(() => new Metric());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Metric> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[29]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Metric()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Metric(Metric other) : this()
  {
    kind_ = other.kind_;
    expression_ = other.expression_ != null ? other.expression_.Clone() : null;
    actionCosts_ = other.actionCosts_.Clone();
    defaultActionCost_ = other.defaultActionCost_ != null ? other.defaultActionCost_.Clone() : null;
    goals_ = other.goals_.Clone();
    timedGoals_ = other.timedGoals_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Metric Clone()
  {
    return new Metric(this);
  }

  /// <summary>Field number for the "kind" field.</summary>
  public const int KindFieldNumber = 1;
  private global::Metric.Types.MetricKind kind_ = 0;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Metric.Types.MetricKind Kind
  {
    get { return kind_; }
    set
    {
      kind_ = value;
    }
  }

  /// <summary>Field number for the "expression" field.</summary>
  public const int ExpressionFieldNumber = 2;
  private global::Expression expression_;
  /// <summary>
  /// Expression to minimize/maximize in the final state.
  /// Empty, if the `kind` is not {MIN/MAX}IMIZE_EXPRESSION_ON_FINAL_STATE
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression Expression
  {
    get { return expression_; }
    set
    {
      expression_ = value;
    }
  }

  /// <summary>Field number for the "action_costs" field.</summary>
  public const int ActionCostsFieldNumber = 3;
  private static readonly pbc::MapField<string, global::Expression>.Codec _map_actionCosts_codec
      = new pbc::MapField<string, global::Expression>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Expression.Parser), 26);
  private readonly pbc::MapField<string, global::Expression> actionCosts_ = new pbc::MapField<string, global::Expression>();
  /// <summary>
  /// If `kind == MINIMIZE_ACTION_COSTS``, then each action is associated to a cost expression.
  ///
  /// TODO: Document what is allowed in the expression. See issue #134
  /// In particular, for this metric to be useful in many practical problems, the cost expression
  /// should allow referring to the action parameters (and possibly the current state at the action start/end).
  /// This is very awkward to do in this setting where the expression is detached from its scope.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::MapField<string, global::Expression> ActionCosts
  {
    get { return actionCosts_; }
  }

  /// <summary>Field number for the "default_action_cost" field.</summary>
  public const int DefaultActionCostFieldNumber = 4;
  private global::Expression defaultActionCost_;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Expression DefaultActionCost
  {
    get { return defaultActionCost_; }
    set
    {
      defaultActionCost_ = value;
    }
  }

  /// <summary>Field number for the "goals" field.</summary>
  public const int GoalsFieldNumber = 5;
  private static readonly pb::FieldCodec<global::GoalWithWeight> _repeated_goals_codec
      = pb::FieldCodec.ForMessage(42, global::GoalWithWeight.Parser);
  private readonly pbc::RepeatedField<global::GoalWithWeight> goals_ = new pbc::RepeatedField<global::GoalWithWeight>();
  /// <summary>
  /// List of goals used to define the oversubscription planning problem.
  /// Empty, if the `kind` is not OVERSUBSCRIPTION
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::GoalWithWeight> Goals
  {
    get { return goals_; }
  }

  /// <summary>Field number for the "timed_goals" field.</summary>
  public const int TimedGoalsFieldNumber = 6;
  private static readonly pb::FieldCodec<global::TimedGoalWithWeight> _repeated_timedGoals_codec
      = pb::FieldCodec.ForMessage(50, global::TimedGoalWithWeight.Parser);
  private readonly pbc::RepeatedField<global::TimedGoalWithWeight> timedGoals_ = new pbc::RepeatedField<global::TimedGoalWithWeight>();
  /// <summary>
  /// List of timed goals used to define the temporal oversubscription planning problem.
  /// Empty, if the `kind` is not TEMPORAL_OVERSUBSCRIPTION
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::TimedGoalWithWeight> TimedGoals
  {
    get { return timedGoals_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Metric);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Metric other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Kind != other.Kind) return false;
    if (!object.Equals(Expression, other.Expression)) return false;
    if (!ActionCosts.Equals(other.ActionCosts)) return false;
    if (!object.Equals(DefaultActionCost, other.DefaultActionCost)) return false;
    if (!goals_.Equals(other.goals_)) return false;
    if (!timedGoals_.Equals(other.timedGoals_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Kind != 0) hash ^= Kind.GetHashCode();
    if (expression_ != null) hash ^= Expression.GetHashCode();
    hash ^= ActionCosts.GetHashCode();
    if (defaultActionCost_ != null) hash ^= DefaultActionCost.GetHashCode();
    hash ^= goals_.GetHashCode();
    hash ^= timedGoals_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Kind != 0)
    {
      output.WriteRawTag(8);
      output.WriteEnum((int)Kind);
    }
    if (expression_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Expression);
    }
    actionCosts_.WriteTo(output, _map_actionCosts_codec);
    if (defaultActionCost_ != null)
    {
      output.WriteRawTag(34);
      output.WriteMessage(DefaultActionCost);
    }
    goals_.WriteTo(output, _repeated_goals_codec);
    timedGoals_.WriteTo(output, _repeated_timedGoals_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Kind != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Kind);
    }
    if (expression_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Expression);
    }
    size += actionCosts_.CalculateSize(_map_actionCosts_codec);
    if (defaultActionCost_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(DefaultActionCost);
    }
    size += goals_.CalculateSize(_repeated_goals_codec);
    size += timedGoals_.CalculateSize(_repeated_timedGoals_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Metric other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Kind != 0)
    {
      Kind = other.Kind;
    }
    if (other.expression_ != null)
    {
      if (expression_ == null)
      {
        expression_ = new global::Expression();
      }
      Expression.MergeFrom(other.Expression);
    }
    actionCosts_.Add(other.actionCosts_);
    if (other.defaultActionCost_ != null)
    {
      if (defaultActionCost_ == null)
      {
        defaultActionCost_ = new global::Expression();
      }
      DefaultActionCost.MergeFrom(other.DefaultActionCost);
    }
    goals_.Add(other.goals_);
    timedGoals_.Add(other.timedGoals_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            kind_ = (global::Metric.Types.MetricKind)input.ReadEnum();
            break;
          }
        case 18:
          {
            if (expression_ == null)
            {
              expression_ = new global::Expression();
            }
            input.ReadMessage(expression_);
            break;
          }
        case 26:
          {
            actionCosts_.AddEntriesFrom(input, _map_actionCosts_codec);
            break;
          }
        case 34:
          {
            if (defaultActionCost_ == null)
            {
              defaultActionCost_ = new global::Expression();
            }
            input.ReadMessage(defaultActionCost_);
            break;
          }
        case 42:
          {
            goals_.AddEntriesFrom(input, _repeated_goals_codec);
            break;
          }
        case 50:
          {
            timedGoals_.AddEntriesFrom(input, _repeated_timedGoals_codec);
            break;
          }
      }
    }
  }

  #region Nested types
  /// <summary>Container for nested types declared in the Metric message type.</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static partial class Types
  {
    public enum MetricKind
    {
      /// <summary>
      /// Minimize the action costs expressed in the `action_costs` field
      /// </summary>
      [pbr::OriginalName("MINIMIZE_ACTION_COSTS")] MinimizeActionCosts = 0,
      /// <summary>
      /// Minimize the length of the resulting sequential plan
      /// </summary>
      [pbr::OriginalName("MINIMIZE_SEQUENTIAL_PLAN_LENGTH")] MinimizeSequentialPlanLength = 1,
      /// <summary>
      /// Minimize the makespan in case of temporal planning
      /// features: durative_actions
      /// </summary>
      [pbr::OriginalName("MINIMIZE_MAKESPAN")] MinimizeMakespan = 2,
      /// <summary>
      /// Minimize the value of the expression defined in the `expression` field
      /// </summary>
      [pbr::OriginalName("MINIMIZE_EXPRESSION_ON_FINAL_STATE")] MinimizeExpressionOnFinalState = 3,
      /// <summary>
      /// Maximize the value of the expression defined in the `expression` field
      /// </summary>
      [pbr::OriginalName("MAXIMIZE_EXPRESSION_ON_FINAL_STATE")] MaximizeExpressionOnFinalState = 4,
      /// <summary>
      /// Maximize the weighted number of goals reached
      /// </summary>
      [pbr::OriginalName("OVERSUBSCRIPTION")] Oversubscription = 5,
      /// <summary>
      /// Maximize the weighted number of timed goals reached
      /// </summary>
      [pbr::OriginalName("TEMPORAL_OVERSUBSCRIPTION")] TemporalOversubscription = 6,
    }

  }
  #endregion

}

public sealed partial class Problem : pb::IMessage<Problem>
{
  private static readonly pb::MessageParser<Problem> _parser = new pb::MessageParser<Problem>(() => new Problem());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Problem> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[30]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Problem()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Problem(Problem other) : this()
  {
    domainName_ = other.domainName_;
    problemName_ = other.problemName_;
    types_ = other.types_.Clone();
    fluents_ = other.fluents_.Clone();
    objects_ = other.objects_.Clone();
    actions_ = other.actions_.Clone();
    initialState_ = other.initialState_.Clone();
    timedEffects_ = other.timedEffects_.Clone();
    goals_ = other.goals_.Clone();
    features_ = other.features_.Clone();
    metrics_ = other.metrics_.Clone();
    hierarchy_ = other.hierarchy_ != null ? other.hierarchy_.Clone() : null;
    schedulingExtension_ = other.schedulingExtension_ != null ? other.schedulingExtension_.Clone() : null;
    trajectoryConstraints_ = other.trajectoryConstraints_.Clone();
    discreteTime_ = other.discreteTime_;
    selfOverlapping_ = other.selfOverlapping_;
    epsilon_ = other.epsilon_ != null ? other.epsilon_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Problem Clone()
  {
    return new Problem(this);
  }

  /// <summary>Field number for the "domain_name" field.</summary>
  public const int DomainNameFieldNumber = 1;
  private string domainName_ = "";
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string DomainName
  {
    get { return domainName_; }
    set
    {
      domainName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "problem_name" field.</summary>
  public const int ProblemNameFieldNumber = 2;
  private string problemName_ = "";
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string ProblemName
  {
    get { return problemName_; }
    set
    {
      problemName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "types" field.</summary>
  public const int Types_FieldNumber = 3;
  private static readonly pb::FieldCodec<global::TypeDeclaration> _repeated_types_codec
      = pb::FieldCodec.ForMessage(26, global::TypeDeclaration.Parser);
  private readonly pbc::RepeatedField<global::TypeDeclaration> types_ = new pbc::RepeatedField<global::TypeDeclaration>();
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::TypeDeclaration> Types_
  {
    get { return types_; }
  }

  /// <summary>Field number for the "fluents" field.</summary>
  public const int FluentsFieldNumber = 4;
  private static readonly pb::FieldCodec<global::Fluent> _repeated_fluents_codec
      = pb::FieldCodec.ForMessage(34, global::Fluent.Parser);
  private readonly pbc::RepeatedField<global::Fluent> fluents_ = new pbc::RepeatedField<global::Fluent>();
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Fluent> Fluents
  {
    get { return fluents_; }
  }

  /// <summary>Field number for the "objects" field.</summary>
  public const int ObjectsFieldNumber = 5;
  private static readonly pb::FieldCodec<global::ObjectDeclaration> _repeated_objects_codec
      = pb::FieldCodec.ForMessage(42, global::ObjectDeclaration.Parser);
  private readonly pbc::RepeatedField<global::ObjectDeclaration> objects_ = new pbc::RepeatedField<global::ObjectDeclaration>();
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::ObjectDeclaration> Objects
  {
    get { return objects_; }
  }

  /// <summary>Field number for the "actions" field.</summary>
  public const int ActionsFieldNumber = 6;
  private static readonly pb::FieldCodec<global::Action> _repeated_actions_codec
      = pb::FieldCodec.ForMessage(50, global::Action.Parser);
  private readonly pbc::RepeatedField<global::Action> actions_ = new pbc::RepeatedField<global::Action>();
  /// <summary>
  /// List of actions in the domain.
  /// features: ACTION_BASED
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Action> Actions
  {
    get { return actions_; }
  }

  /// <summary>Field number for the "initial_state" field.</summary>
  public const int InitialStateFieldNumber = 7;
  private static readonly pb::FieldCodec<global::Assignment> _repeated_initialState_codec
      = pb::FieldCodec.ForMessage(58, global::Assignment.Parser);
  private readonly pbc::RepeatedField<global::Assignment> initialState_ = new pbc::RepeatedField<global::Assignment>();
  /// <summary>
  /// Initial state, including default values of state variables.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Assignment> InitialState
  {
    get { return initialState_; }
  }

  /// <summary>Field number for the "timed_effects" field.</summary>
  public const int TimedEffectsFieldNumber = 8;
  private static readonly pb::FieldCodec<global::TimedEffect> _repeated_timedEffects_codec
      = pb::FieldCodec.ForMessage(66, global::TimedEffect.Parser);
  private readonly pbc::RepeatedField<global::TimedEffect> timedEffects_ = new pbc::RepeatedField<global::TimedEffect>();
  /// <summary>
  /// Facts and effects that are expected to occur strictly later than the initial state.
  /// features: TIMED_EFFECTS
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::TimedEffect> TimedEffects
  {
    get { return timedEffects_; }
  }

  /// <summary>Field number for the "goals" field.</summary>
  public const int GoalsFieldNumber = 9;
  private static readonly pb::FieldCodec<global::Goal> _repeated_goals_codec
      = pb::FieldCodec.ForMessage(74, global::Goal.Parser);
  private readonly pbc::RepeatedField<global::Goal> goals_ = new pbc::RepeatedField<global::Goal>();
  /// <summary>
  /// Goals of the planning problem.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Goal> Goals
  {
    get { return goals_; }
  }

  /// <summary>Field number for the "features" field.</summary>
  public const int FeaturesFieldNumber = 10;
  private static readonly pb::FieldCodec<global::Feature> _repeated_features_codec
      = pb::FieldCodec.ForEnum(82, x => (int)x, x => (global::Feature)x);
  private readonly pbc::RepeatedField<global::Feature> features_ = new pbc::RepeatedField<global::Feature>();
  /// <summary>
  /// all features of the problem
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Feature> Features
  {
    get { return features_; }
  }

  /// <summary>Field number for the "metrics" field.</summary>
  public const int MetricsFieldNumber = 11;
  private static readonly pb::FieldCodec<global::Metric> _repeated_metrics_codec
      = pb::FieldCodec.ForMessage(90, global::Metric.Parser);
  private readonly pbc::RepeatedField<global::Metric> metrics_ = new pbc::RepeatedField<global::Metric>();
  /// <summary>
  /// The plan quality metrics
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Metric> Metrics
  {
    get { return metrics_; }
  }

  /// <summary>Field number for the "hierarchy" field.</summary>
  public const int HierarchyFieldNumber = 12;
  private global::Hierarchy hierarchy_;
  /// <summary>
  /// If the problem is hierarchical, defines the tasks and methods as well as the initial task network.
  /// features: HIERARCHICAL
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Hierarchy Hierarchy
  {
    get { return hierarchy_; }
    set
    {
      hierarchy_ = value;
    }
  }

  /// <summary>Field number for the "scheduling_extension" field.</summary>
  public const int SchedulingExtensionFieldNumber = 17;
  private global::SchedulingExtension schedulingExtension_;
  /// <summary>
  /// Scheduling-specific extension of the problem.
  /// features: SCHEDULING
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::SchedulingExtension SchedulingExtension
  {
    get { return schedulingExtension_; }
    set
    {
      schedulingExtension_ = value;
    }
  }

  /// <summary>Field number for the "trajectory_constraints" field.</summary>
  public const int TrajectoryConstraintsFieldNumber = 13;
  private static readonly pb::FieldCodec<global::Expression> _repeated_trajectoryConstraints_codec
      = pb::FieldCodec.ForMessage(106, global::Expression.Parser);
  private readonly pbc::RepeatedField<global::Expression> trajectoryConstraints_ = new pbc::RepeatedField<global::Expression>();
  /// <summary>
  /// Trajectory constraints of the planning problem.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Expression> TrajectoryConstraints
  {
    get { return trajectoryConstraints_; }
  }

  /// <summary>Field number for the "discrete_time" field.</summary>
  public const int DiscreteTimeFieldNumber = 14;
  private bool discreteTime_;
  /// <summary>
  /// Flag defining if the time is discrete
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool DiscreteTime
  {
    get { return discreteTime_; }
    set
    {
      discreteTime_ = value;
    }
  }

  /// <summary>Field number for the "self_overlapping" field.</summary>
  public const int SelfOverlappingFieldNumber = 15;
  private bool selfOverlapping_;
  /// <summary>
  /// Flag defining if the self_overlapping is allowed
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool SelfOverlapping
  {
    get { return selfOverlapping_; }
    set
    {
      selfOverlapping_ = value;
    }
  }

  /// <summary>Field number for the "epsilon" field.</summary>
  public const int EpsilonFieldNumber = 16;
  private global::Real epsilon_;
  /// <summary>
  /// Optional. epsilon required by the problem
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Real Epsilon
  {
    get { return epsilon_; }
    set
    {
      epsilon_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Problem);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Problem other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (DomainName != other.DomainName) return false;
    if (ProblemName != other.ProblemName) return false;
    if (!types_.Equals(other.types_)) return false;
    if (!fluents_.Equals(other.fluents_)) return false;
    if (!objects_.Equals(other.objects_)) return false;
    if (!actions_.Equals(other.actions_)) return false;
    if (!initialState_.Equals(other.initialState_)) return false;
    if (!timedEffects_.Equals(other.timedEffects_)) return false;
    if (!goals_.Equals(other.goals_)) return false;
    if (!features_.Equals(other.features_)) return false;
    if (!metrics_.Equals(other.metrics_)) return false;
    if (!object.Equals(Hierarchy, other.Hierarchy)) return false;
    if (!object.Equals(SchedulingExtension, other.SchedulingExtension)) return false;
    if (!trajectoryConstraints_.Equals(other.trajectoryConstraints_)) return false;
    if (DiscreteTime != other.DiscreteTime) return false;
    if (SelfOverlapping != other.SelfOverlapping) return false;
    if (!object.Equals(Epsilon, other.Epsilon)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (DomainName.Length != 0) hash ^= DomainName.GetHashCode();
    if (ProblemName.Length != 0) hash ^= ProblemName.GetHashCode();
    hash ^= types_.GetHashCode();
    hash ^= fluents_.GetHashCode();
    hash ^= objects_.GetHashCode();
    hash ^= actions_.GetHashCode();
    hash ^= initialState_.GetHashCode();
    hash ^= timedEffects_.GetHashCode();
    hash ^= goals_.GetHashCode();
    hash ^= features_.GetHashCode();
    hash ^= metrics_.GetHashCode();
    if (hierarchy_ != null) hash ^= Hierarchy.GetHashCode();
    if (schedulingExtension_ != null) hash ^= SchedulingExtension.GetHashCode();
    hash ^= trajectoryConstraints_.GetHashCode();
    if (DiscreteTime != false) hash ^= DiscreteTime.GetHashCode();
    if (SelfOverlapping != false) hash ^= SelfOverlapping.GetHashCode();
    if (epsilon_ != null) hash ^= Epsilon.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (DomainName.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(DomainName);
    }
    if (ProblemName.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(ProblemName);
    }
    types_.WriteTo(output, _repeated_types_codec);
    fluents_.WriteTo(output, _repeated_fluents_codec);
    objects_.WriteTo(output, _repeated_objects_codec);
    actions_.WriteTo(output, _repeated_actions_codec);
    initialState_.WriteTo(output, _repeated_initialState_codec);
    timedEffects_.WriteTo(output, _repeated_timedEffects_codec);
    goals_.WriteTo(output, _repeated_goals_codec);
    features_.WriteTo(output, _repeated_features_codec);
    metrics_.WriteTo(output, _repeated_metrics_codec);
    if (hierarchy_ != null)
    {
      output.WriteRawTag(98);
      output.WriteMessage(Hierarchy);
    }
    trajectoryConstraints_.WriteTo(output, _repeated_trajectoryConstraints_codec);
    if (DiscreteTime != false)
    {
      output.WriteRawTag(112);
      output.WriteBool(DiscreteTime);
    }
    if (SelfOverlapping != false)
    {
      output.WriteRawTag(120);
      output.WriteBool(SelfOverlapping);
    }
    if (epsilon_ != null)
    {
      output.WriteRawTag(130, 1);
      output.WriteMessage(Epsilon);
    }
    if (schedulingExtension_ != null)
    {
      output.WriteRawTag(138, 1);
      output.WriteMessage(SchedulingExtension);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (DomainName.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(DomainName);
    }
    if (ProblemName.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(ProblemName);
    }
    size += types_.CalculateSize(_repeated_types_codec);
    size += fluents_.CalculateSize(_repeated_fluents_codec);
    size += objects_.CalculateSize(_repeated_objects_codec);
    size += actions_.CalculateSize(_repeated_actions_codec);
    size += initialState_.CalculateSize(_repeated_initialState_codec);
    size += timedEffects_.CalculateSize(_repeated_timedEffects_codec);
    size += goals_.CalculateSize(_repeated_goals_codec);
    size += features_.CalculateSize(_repeated_features_codec);
    size += metrics_.CalculateSize(_repeated_metrics_codec);
    if (hierarchy_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Hierarchy);
    }
    if (schedulingExtension_ != null)
    {
      size += 2 + pb::CodedOutputStream.ComputeMessageSize(SchedulingExtension);
    }
    size += trajectoryConstraints_.CalculateSize(_repeated_trajectoryConstraints_codec);
    if (DiscreteTime != false)
    {
      size += 1 + 1;
    }
    if (SelfOverlapping != false)
    {
      size += 1 + 1;
    }
    if (epsilon_ != null)
    {
      size += 2 + pb::CodedOutputStream.ComputeMessageSize(Epsilon);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Problem other)
  {
    if (other == null)
    {
      return;
    }
    if (other.DomainName.Length != 0)
    {
      DomainName = other.DomainName;
    }
    if (other.ProblemName.Length != 0)
    {
      ProblemName = other.ProblemName;
    }
    types_.Add(other.types_);
    fluents_.Add(other.fluents_);
    objects_.Add(other.objects_);
    actions_.Add(other.actions_);
    initialState_.Add(other.initialState_);
    timedEffects_.Add(other.timedEffects_);
    goals_.Add(other.goals_);
    features_.Add(other.features_);
    metrics_.Add(other.metrics_);
    if (other.hierarchy_ != null)
    {
      if (hierarchy_ == null)
      {
        hierarchy_ = new global::Hierarchy();
      }
      Hierarchy.MergeFrom(other.Hierarchy);
    }
    if (other.schedulingExtension_ != null)
    {
      if (schedulingExtension_ == null)
      {
        schedulingExtension_ = new global::SchedulingExtension();
      }
      SchedulingExtension.MergeFrom(other.SchedulingExtension);
    }
    trajectoryConstraints_.Add(other.trajectoryConstraints_);
    if (other.DiscreteTime != false)
    {
      DiscreteTime = other.DiscreteTime;
    }
    if (other.SelfOverlapping != false)
    {
      SelfOverlapping = other.SelfOverlapping;
    }
    if (other.epsilon_ != null)
    {
      if (epsilon_ == null)
      {
        epsilon_ = new global::Real();
      }
      Epsilon.MergeFrom(other.Epsilon);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            DomainName = input.ReadString();
            break;
          }
        case 18:
          {
            ProblemName = input.ReadString();
            break;
          }
        case 26:
          {
            types_.AddEntriesFrom(input, _repeated_types_codec);
            break;
          }
        case 34:
          {
            fluents_.AddEntriesFrom(input, _repeated_fluents_codec);
            break;
          }
        case 42:
          {
            objects_.AddEntriesFrom(input, _repeated_objects_codec);
            break;
          }
        case 50:
          {
            actions_.AddEntriesFrom(input, _repeated_actions_codec);
            break;
          }
        case 58:
          {
            initialState_.AddEntriesFrom(input, _repeated_initialState_codec);
            break;
          }
        case 66:
          {
            timedEffects_.AddEntriesFrom(input, _repeated_timedEffects_codec);
            break;
          }
        case 74:
          {
            goals_.AddEntriesFrom(input, _repeated_goals_codec);
            break;
          }
        case 82:
        case 80:
          {
            features_.AddEntriesFrom(input, _repeated_features_codec);
            break;
          }
        case 90:
          {
            metrics_.AddEntriesFrom(input, _repeated_metrics_codec);
            break;
          }
        case 98:
          {
            if (hierarchy_ == null)
            {
              hierarchy_ = new global::Hierarchy();
            }
            input.ReadMessage(hierarchy_);
            break;
          }
        case 106:
          {
            trajectoryConstraints_.AddEntriesFrom(input, _repeated_trajectoryConstraints_codec);
            break;
          }
        case 112:
          {
            DiscreteTime = input.ReadBool();
            break;
          }
        case 120:
          {
            SelfOverlapping = input.ReadBool();
            break;
          }
        case 130:
          {
            if (epsilon_ == null)
            {
              epsilon_ = new global::Real();
            }
            input.ReadMessage(epsilon_);
            break;
          }
        case 138:
          {
            if (schedulingExtension_ == null)
            {
              schedulingExtension_ = new global::SchedulingExtension();
            }
            input.ReadMessage(schedulingExtension_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// Representation of an action instance that appears in a plan.
/// </summary>
public sealed partial class ActionInstance : pb::IMessage<ActionInstance>
{
  private static readonly pb::MessageParser<ActionInstance> _parser = new pb::MessageParser<ActionInstance>(() => new ActionInstance());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<ActionInstance> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[31]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ActionInstance()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ActionInstance(ActionInstance other) : this()
  {
    id_ = other.id_;
    actionName_ = other.actionName_;
    parameters_ = other.parameters_.Clone();
    startTime_ = other.startTime_ != null ? other.startTime_.Clone() : null;
    endTime_ = other.endTime_ != null ? other.endTime_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ActionInstance Clone()
  {
    return new ActionInstance(this);
  }

  /// <summary>Field number for the "id" field.</summary>
  public const int IdFieldNumber = 1;
  private string id_ = "";
  /// <summary>
  /// Optional. A unique identifier of the action that might be used to refer to it (e.g. in HTN plans).
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Id
  {
    get { return id_; }
    set
    {
      id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "action_name" field.</summary>
  public const int ActionNameFieldNumber = 2;
  private string actionName_ = "";
  /// <summary>
  /// name of the action
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string ActionName
  {
    get { return actionName_; }
    set
    {
      actionName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parameters" field.</summary>
  public const int ParametersFieldNumber = 3;
  private static readonly pb::FieldCodec<global::Atom> _repeated_parameters_codec
      = pb::FieldCodec.ForMessage(26, global::Atom.Parser);
  private readonly pbc::RepeatedField<global::Atom> parameters_ = new pbc::RepeatedField<global::Atom>();
  /// <summary>
  /// Parameters of the action instance, required to be constants.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Atom> Parameters
  {
    get { return parameters_; }
  }

  /// <summary>Field number for the "start_time" field.</summary>
  public const int StartTimeFieldNumber = 4;
  private global::Real startTime_;
  /// <summary>
  /// Start time of the action. The default 0 value is OK in the case of non-temporal planning
  /// feature: [DURATIVE_ACTIONS]
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Real StartTime
  {
    get { return startTime_; }
    set
    {
      startTime_ = value;
    }
  }

  /// <summary>Field number for the "end_time" field.</summary>
  public const int EndTimeFieldNumber = 5;
  private global::Real endTime_;
  /// <summary>
  /// End time of the action. The default 0 value is OK in the case of non-temporal planning
  /// feature: [DURATIVE_ACTIONS]
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Real EndTime
  {
    get { return endTime_; }
    set
    {
      endTime_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as ActionInstance);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(ActionInstance other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Id != other.Id) return false;
    if (ActionName != other.ActionName) return false;
    if (!parameters_.Equals(other.parameters_)) return false;
    if (!object.Equals(StartTime, other.StartTime)) return false;
    if (!object.Equals(EndTime, other.EndTime)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Id.Length != 0) hash ^= Id.GetHashCode();
    if (ActionName.Length != 0) hash ^= ActionName.GetHashCode();
    hash ^= parameters_.GetHashCode();
    if (startTime_ != null) hash ^= StartTime.GetHashCode();
    if (endTime_ != null) hash ^= EndTime.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Id.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Id);
    }
    if (ActionName.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(ActionName);
    }
    parameters_.WriteTo(output, _repeated_parameters_codec);
    if (startTime_ != null)
    {
      output.WriteRawTag(34);
      output.WriteMessage(StartTime);
    }
    if (endTime_ != null)
    {
      output.WriteRawTag(42);
      output.WriteMessage(EndTime);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Id.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
    }
    if (ActionName.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(ActionName);
    }
    size += parameters_.CalculateSize(_repeated_parameters_codec);
    if (startTime_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(StartTime);
    }
    if (endTime_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(EndTime);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(ActionInstance other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Id.Length != 0)
    {
      Id = other.Id;
    }
    if (other.ActionName.Length != 0)
    {
      ActionName = other.ActionName;
    }
    parameters_.Add(other.parameters_);
    if (other.startTime_ != null)
    {
      if (startTime_ == null)
      {
        startTime_ = new global::Real();
      }
      StartTime.MergeFrom(other.StartTime);
    }
    if (other.endTime_ != null)
    {
      if (endTime_ == null)
      {
        endTime_ = new global::Real();
      }
      EndTime.MergeFrom(other.EndTime);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Id = input.ReadString();
            break;
          }
        case 18:
          {
            ActionName = input.ReadString();
            break;
          }
        case 26:
          {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
        case 34:
          {
            if (startTime_ == null)
            {
              startTime_ = new global::Real();
            }
            input.ReadMessage(startTime_);
            break;
          }
        case 42:
          {
            if (endTime_ == null)
            {
              endTime_ = new global::Real();
            }
            input.ReadMessage(endTime_);
            break;
          }
      }
    }
  }

}

public sealed partial class MethodInstance : pb::IMessage<MethodInstance>
{
  private static readonly pb::MessageParser<MethodInstance> _parser = new pb::MessageParser<MethodInstance>(() => new MethodInstance());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<MethodInstance> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[32]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public MethodInstance()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public MethodInstance(MethodInstance other) : this()
  {
    id_ = other.id_;
    methodName_ = other.methodName_;
    parameters_ = other.parameters_.Clone();
    subtasks_ = other.subtasks_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public MethodInstance Clone()
  {
    return new MethodInstance(this);
  }

  /// <summary>Field number for the "id" field.</summary>
  public const int IdFieldNumber = 1;
  private string id_ = "";
  /// <summary>
  ///  A unique identifier of the method that is used to refer to it in the hierarchy.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Id
  {
    get { return id_; }
    set
    {
      id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "method_name" field.</summary>
  public const int MethodNameFieldNumber = 2;
  private string methodName_ = "";
  /// <summary>
  /// name of the method
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string MethodName
  {
    get { return methodName_; }
    set
    {
      methodName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  /// <summary>Field number for the "parameters" field.</summary>
  public const int ParametersFieldNumber = 3;
  private static readonly pb::FieldCodec<global::Atom> _repeated_parameters_codec
      = pb::FieldCodec.ForMessage(26, global::Atom.Parser);
  private readonly pbc::RepeatedField<global::Atom> parameters_ = new pbc::RepeatedField<global::Atom>();
  /// <summary>
  /// Parameters of the method instance, required to be constants.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::Atom> Parameters
  {
    get { return parameters_; }
  }

  /// <summary>Field number for the "subtasks" field.</summary>
  public const int SubtasksFieldNumber = 6;
  private static readonly pbc::MapField<string, string>.Codec _map_subtasks_codec
      = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 50);
  private readonly pbc::MapField<string, string> subtasks_ = new pbc::MapField<string, string>();
  /// <summary>
  /// A mapping of the IDs of the method's subtasks into the IDs of the action/methods that refine them.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::MapField<string, string> Subtasks
  {
    get { return subtasks_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as MethodInstance);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(MethodInstance other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Id != other.Id) return false;
    if (MethodName != other.MethodName) return false;
    if (!parameters_.Equals(other.parameters_)) return false;
    if (!Subtasks.Equals(other.Subtasks)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Id.Length != 0) hash ^= Id.GetHashCode();
    if (MethodName.Length != 0) hash ^= MethodName.GetHashCode();
    hash ^= parameters_.GetHashCode();
    hash ^= Subtasks.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Id.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Id);
    }
    if (MethodName.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(MethodName);
    }
    parameters_.WriteTo(output, _repeated_parameters_codec);
    subtasks_.WriteTo(output, _map_subtasks_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Id.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
    }
    if (MethodName.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(MethodName);
    }
    size += parameters_.CalculateSize(_repeated_parameters_codec);
    size += subtasks_.CalculateSize(_map_subtasks_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(MethodInstance other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Id.Length != 0)
    {
      Id = other.Id;
    }
    if (other.MethodName.Length != 0)
    {
      MethodName = other.MethodName;
    }
    parameters_.Add(other.parameters_);
    subtasks_.Add(other.subtasks_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Id = input.ReadString();
            break;
          }
        case 18:
          {
            MethodName = input.ReadString();
            break;
          }
        case 26:
          {
            parameters_.AddEntriesFrom(input, _repeated_parameters_codec);
            break;
          }
        case 50:
          {
            subtasks_.AddEntriesFrom(input, _map_subtasks_codec);
            break;
          }
      }
    }
  }

}

public sealed partial class PlanHierarchy : pb::IMessage<PlanHierarchy>
{
  private static readonly pb::MessageParser<PlanHierarchy> _parser = new pb::MessageParser<PlanHierarchy>(() => new PlanHierarchy());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<PlanHierarchy> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[33]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanHierarchy()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanHierarchy(PlanHierarchy other) : this()
  {
    rootTasks_ = other.rootTasks_.Clone();
    methods_ = other.methods_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanHierarchy Clone()
  {
    return new PlanHierarchy(this);
  }

  /// <summary>Field number for the "root_tasks" field.</summary>
  public const int RootTasksFieldNumber = 1;
  private static readonly pbc::MapField<string, string>.Codec _map_rootTasks_codec
      = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 10);
  private readonly pbc::MapField<string, string> rootTasks_ = new pbc::MapField<string, string>();
  /// <summary>
  /// A mapping of the root task IDs into the IDs of the actions and methods that refine them.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::MapField<string, string> RootTasks
  {
    get { return rootTasks_; }
  }

  /// <summary>Field number for the "methods" field.</summary>
  public const int MethodsFieldNumber = 2;
  private static readonly pb::FieldCodec<global::MethodInstance> _repeated_methods_codec
      = pb::FieldCodec.ForMessage(18, global::MethodInstance.Parser);
  private readonly pbc::RepeatedField<global::MethodInstance> methods_ = new pbc::RepeatedField<global::MethodInstance>();
  /// <summary>
  /// Instances of all methods used in the plan.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::MethodInstance> Methods
  {
    get { return methods_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as PlanHierarchy);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(PlanHierarchy other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!RootTasks.Equals(other.RootTasks)) return false;
    if (!methods_.Equals(other.methods_)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    hash ^= RootTasks.GetHashCode();
    hash ^= methods_.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    rootTasks_.WriteTo(output, _map_rootTasks_codec);
    methods_.WriteTo(output, _repeated_methods_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    size += rootTasks_.CalculateSize(_map_rootTasks_codec);
    size += methods_.CalculateSize(_repeated_methods_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(PlanHierarchy other)
  {
    if (other == null)
    {
      return;
    }
    rootTasks_.Add(other.rootTasks_);
    methods_.Add(other.methods_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            rootTasks_.AddEntriesFrom(input, _map_rootTasks_codec);
            break;
          }
        case 18:
          {
            methods_.AddEntriesFrom(input, _repeated_methods_codec);
            break;
          }
      }
    }
  }

}

public sealed partial class Plan : pb::IMessage<Plan>
{
  private static readonly pb::MessageParser<Plan> _parser = new pb::MessageParser<Plan>(() => new Plan());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Plan> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[34]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Plan()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Plan(Plan other) : this()
  {
    actions_ = other.actions_.Clone();
    hierarchy_ = other.hierarchy_ != null ? other.hierarchy_.Clone() : null;
    schedule_ = other.schedule_ != null ? other.schedule_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Plan Clone()
  {
    return new Plan(this);
  }

  /// <summary>Field number for the "actions" field.</summary>
  public const int ActionsFieldNumber = 1;
  private static readonly pb::FieldCodec<global::ActionInstance> _repeated_actions_codec
      = pb::FieldCodec.ForMessage(10, global::ActionInstance.Parser);
  private readonly pbc::RepeatedField<global::ActionInstance> actions_ = new pbc::RepeatedField<global::ActionInstance>();
  /// <summary>
  /// An ordered sequence of actions that appear in the plan.
  /// The order of the actions in the list must be compatible with the partial order of the start times.
  /// In case of non-temporal planning, this allows having all start time at 0 and only rely on the order in this sequence.
  /// features: ACTION_BASED
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::ActionInstance> Actions
  {
    get { return actions_; }
  }

  /// <summary>Field number for the "hierarchy" field.</summary>
  public const int HierarchyFieldNumber = 2;
  private global::PlanHierarchy hierarchy_;
  /// <summary>
  /// When the plan is hierarchical, this object provides the decomposition of hte root tasks into the actions of the plan
  /// feature: HIERARCHY
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::PlanHierarchy Hierarchy
  {
    get { return hierarchy_; }
    set
    {
      hierarchy_ = value;
    }
  }

  /// <summary>Field number for the "schedule" field.</summary>
  public const int ScheduleFieldNumber = 3;
  private global::Schedule schedule_;
  /// <summary>
  /// Solution representation of a scheduling problem.
  /// feature: SCHEDULING
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Schedule Schedule
  {
    get { return schedule_; }
    set
    {
      schedule_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Plan);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Plan other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!actions_.Equals(other.actions_)) return false;
    if (!object.Equals(Hierarchy, other.Hierarchy)) return false;
    if (!object.Equals(Schedule, other.Schedule)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    hash ^= actions_.GetHashCode();
    if (hierarchy_ != null) hash ^= Hierarchy.GetHashCode();
    if (schedule_ != null) hash ^= Schedule.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    actions_.WriteTo(output, _repeated_actions_codec);
    if (hierarchy_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Hierarchy);
    }
    if (schedule_ != null)
    {
      output.WriteRawTag(26);
      output.WriteMessage(Schedule);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    size += actions_.CalculateSize(_repeated_actions_codec);
    if (hierarchy_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Hierarchy);
    }
    if (schedule_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Schedule);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Plan other)
  {
    if (other == null)
    {
      return;
    }
    actions_.Add(other.actions_);
    if (other.hierarchy_ != null)
    {
      if (hierarchy_ == null)
      {
        hierarchy_ = new global::PlanHierarchy();
      }
      Hierarchy.MergeFrom(other.Hierarchy);
    }
    if (other.schedule_ != null)
    {
      if (schedule_ == null)
      {
        schedule_ = new global::Schedule();
      }
      Schedule.MergeFrom(other.Schedule);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            actions_.AddEntriesFrom(input, _repeated_actions_codec);
            break;
          }
        case 18:
          {
            if (hierarchy_ == null)
            {
              hierarchy_ = new global::PlanHierarchy();
            }
            input.ReadMessage(hierarchy_);
            break;
          }
        case 26:
          {
            if (schedule_ == null)
            {
              schedule_ = new global::Schedule();
            }
            input.ReadMessage(schedule_);
            break;
          }
      }
    }
  }

}

public sealed partial class PlanRequest : pb::IMessage<PlanRequest>
{
  private static readonly pb::MessageParser<PlanRequest> _parser = new pb::MessageParser<PlanRequest>(() => new PlanRequest());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<PlanRequest> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[35]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanRequest()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanRequest(PlanRequest other) : this()
  {
    problem_ = other.problem_ != null ? other.problem_.Clone() : null;
    resolutionMode_ = other.resolutionMode_;
    timeout_ = other.timeout_;
    engineOptions_ = other.engineOptions_.Clone();
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanRequest Clone()
  {
    return new PlanRequest(this);
  }

  /// <summary>Field number for the "problem" field.</summary>
  public const int ProblemFieldNumber = 1;
  private global::Problem problem_;
  /// <summary>
  /// Problem that should be solved.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Problem Problem
  {
    get { return problem_; }
    set
    {
      problem_ = value;
    }
  }

  /// <summary>Field number for the "resolution_mode" field.</summary>
  public const int ResolutionModeFieldNumber = 2;
  private global::PlanRequest.Types.Mode resolutionMode_ = 0;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::PlanRequest.Types.Mode ResolutionMode
  {
    get { return resolutionMode_; }
    set
    {
      resolutionMode_ = value;
    }
  }

  /// <summary>Field number for the "timeout" field.</summary>
  public const int TimeoutFieldNumber = 3;
  private double timeout_;
  /// <summary>
  /// Max allowed runtime time in seconds.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public double Timeout
  {
    get { return timeout_; }
    set
    {
      timeout_ = value;
    }
  }

  /// <summary>Field number for the "engine_options" field.</summary>
  public const int EngineOptionsFieldNumber = 4;
  private static readonly pbc::MapField<string, string>.Codec _map_engineOptions_codec
      = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 34);
  private readonly pbc::MapField<string, string> engineOptions_ = new pbc::MapField<string, string>();
  /// <summary>
  /// Engine specific options to be passed to the engine
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::MapField<string, string> EngineOptions
  {
    get { return engineOptions_; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as PlanRequest);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(PlanRequest other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Problem, other.Problem)) return false;
    if (ResolutionMode != other.ResolutionMode) return false;
    if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Timeout, other.Timeout)) return false;
    if (!EngineOptions.Equals(other.EngineOptions)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (problem_ != null) hash ^= Problem.GetHashCode();
    if (ResolutionMode != 0) hash ^= ResolutionMode.GetHashCode();
    if (Timeout != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Timeout);
    hash ^= EngineOptions.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (problem_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Problem);
    }
    if (ResolutionMode != 0)
    {
      output.WriteRawTag(16);
      output.WriteEnum((int)ResolutionMode);
    }
    if (Timeout != 0D)
    {
      output.WriteRawTag(25);
      output.WriteDouble(Timeout);
    }
    engineOptions_.WriteTo(output, _map_engineOptions_codec);
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (problem_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Problem);
    }
    if (ResolutionMode != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)ResolutionMode);
    }
    if (Timeout != 0D)
    {
      size += 1 + 8;
    }
    size += engineOptions_.CalculateSize(_map_engineOptions_codec);
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(PlanRequest other)
  {
    if (other == null)
    {
      return;
    }
    if (other.problem_ != null)
    {
      if (problem_ == null)
      {
        problem_ = new global::Problem();
      }
      Problem.MergeFrom(other.Problem);
    }
    if (other.ResolutionMode != 0)
    {
      ResolutionMode = other.ResolutionMode;
    }
    if (other.Timeout != 0D)
    {
      Timeout = other.Timeout;
    }
    engineOptions_.Add(other.engineOptions_);
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (problem_ == null)
            {
              problem_ = new global::Problem();
            }
            input.ReadMessage(problem_);
            break;
          }
        case 16:
          {
            resolutionMode_ = (global::PlanRequest.Types.Mode)input.ReadEnum();
            break;
          }
        case 25:
          {
            Timeout = input.ReadDouble();
            break;
          }
        case 34:
          {
            engineOptions_.AddEntriesFrom(input, _map_engineOptions_codec);
            break;
          }
      }
    }
  }

  #region Nested types
  /// <summary>Container for nested types declared in the PlanRequest message type.</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static partial class Types
  {
    public enum Mode
    {
      [pbr::OriginalName("SATISFIABLE")] Satisfiable = 0,
      [pbr::OriginalName("SOLVED_OPTIMALLY")] SolvedOptimally = 1,
    }

  }
  #endregion

}

public sealed partial class ValidationRequest : pb::IMessage<ValidationRequest>
{
  private static readonly pb::MessageParser<ValidationRequest> _parser = new pb::MessageParser<ValidationRequest>(() => new ValidationRequest());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<ValidationRequest> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[36]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ValidationRequest()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ValidationRequest(ValidationRequest other) : this()
  {
    problem_ = other.problem_ != null ? other.problem_.Clone() : null;
    plan_ = other.plan_ != null ? other.plan_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ValidationRequest Clone()
  {
    return new ValidationRequest(this);
  }

  /// <summary>Field number for the "problem" field.</summary>
  public const int ProblemFieldNumber = 1;
  private global::Problem problem_;
  /// <summary>
  /// Problem to be validated.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Problem Problem
  {
    get { return problem_; }
    set
    {
      problem_ = value;
    }
  }

  /// <summary>Field number for the "plan" field.</summary>
  public const int PlanFieldNumber = 2;
  private global::Plan plan_;
  /// <summary>
  /// Plan to validate.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Plan Plan
  {
    get { return plan_; }
    set
    {
      plan_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as ValidationRequest);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(ValidationRequest other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Problem, other.Problem)) return false;
    if (!object.Equals(Plan, other.Plan)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (problem_ != null) hash ^= Problem.GetHashCode();
    if (plan_ != null) hash ^= Plan.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (problem_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Problem);
    }
    if (plan_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Plan);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (problem_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Problem);
    }
    if (plan_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Plan);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(ValidationRequest other)
  {
    if (other == null)
    {
      return;
    }
    if (other.problem_ != null)
    {
      if (problem_ == null)
      {
        problem_ = new global::Problem();
      }
      Problem.MergeFrom(other.Problem);
    }
    if (other.plan_ != null)
    {
      if (plan_ == null)
      {
        plan_ = new global::Plan();
      }
      Plan.MergeFrom(other.Plan);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (problem_ == null)
            {
              problem_ = new global::Problem();
            }
            input.ReadMessage(problem_);
            break;
          }
        case 18:
          {
            if (plan_ == null)
            {
              plan_ = new global::Plan();
            }
            input.ReadMessage(plan_);
            break;
          }
      }
    }
  }

}

/// <summary>
/// A freely formatted logging message.
/// Each message is annotated with its criticality level from the minimal (DEBUG) to the maximal (ERROR).
/// Criticality level is expected to be used by an end user to decide the level of verbosity.
/// </summary>
public sealed partial class LogMessage : pb::IMessage<LogMessage>
{
  private static readonly pb::MessageParser<LogMessage> _parser = new pb::MessageParser<LogMessage>(() => new LogMessage());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<LogMessage> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[37]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public LogMessage()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public LogMessage(LogMessage other) : this()
  {
    level_ = other.level_;
    message_ = other.message_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public LogMessage Clone()
  {
    return new LogMessage(this);
  }

  /// <summary>Field number for the "level" field.</summary>
  public const int LevelFieldNumber = 1;
  private global::LogMessage.Types.LogLevel level_ = 0;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::LogMessage.Types.LogLevel Level
  {
    get { return level_; }
    set
    {
      level_ = value;
    }
  }

  /// <summary>Field number for the "message" field.</summary>
  public const int MessageFieldNumber = 2;
  private string message_ = "";
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Message
  {
    get { return message_; }
    set
    {
      message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as LogMessage);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(LogMessage other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Level != other.Level) return false;
    if (Message != other.Message) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Level != 0) hash ^= Level.GetHashCode();
    if (Message.Length != 0) hash ^= Message.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Level != 0)
    {
      output.WriteRawTag(8);
      output.WriteEnum((int)Level);
    }
    if (Message.Length != 0)
    {
      output.WriteRawTag(18);
      output.WriteString(Message);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Level != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Level);
    }
    if (Message.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(LogMessage other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Level != 0)
    {
      Level = other.Level;
    }
    if (other.Message.Length != 0)
    {
      Message = other.Message;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            level_ = (global::LogMessage.Types.LogLevel)input.ReadEnum();
            break;
          }
        case 18:
          {
            Message = input.ReadString();
            break;
          }
      }
    }
  }

  #region Nested types
  /// <summary>Container for nested types declared in the LogMessage message type.</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static partial class Types
  {
    public enum LogLevel
    {
      [pbr::OriginalName("DEBUG")] Debug = 0,
      [pbr::OriginalName("INFO")] Info = 1,
      [pbr::OriginalName("WARNING")] Warning = 2,
      [pbr::OriginalName("ERROR")] Error = 3,
    }

  }
  #endregion

}

/// <summary>
/// Message sent by engine.
/// Contains the engine exit status as well as the best plan found if any.
/// </summary>
public sealed partial class PlanGenerationResult : pb::IMessage<PlanGenerationResult>
{
  private static readonly pb::MessageParser<PlanGenerationResult> _parser = new pb::MessageParser<PlanGenerationResult>(() => new PlanGenerationResult());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<PlanGenerationResult> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[38]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanGenerationResult()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanGenerationResult(PlanGenerationResult other) : this()
  {
    status_ = other.status_;
    plan_ = other.plan_ != null ? other.plan_.Clone() : null;
    metrics_ = other.metrics_.Clone();
    logMessages_ = other.logMessages_.Clone();
    engine_ = other.engine_ != null ? other.engine_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public PlanGenerationResult Clone()
  {
    return new PlanGenerationResult(this);
  }

  /// <summary>Field number for the "status" field.</summary>
  public const int StatusFieldNumber = 1;
  private global::PlanGenerationResult.Types.Status status_ = 0;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::PlanGenerationResult.Types.Status Status
  {
    get { return status_; }
    set
    {
      status_ = value;
    }
  }

  /// <summary>Field number for the "plan" field.</summary>
  public const int PlanFieldNumber = 2;
  private global::Plan plan_;
  /// <summary>
  /// Optional. Best plan found if any.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Plan Plan
  {
    get { return plan_; }
    set
    {
      plan_ = value;
    }
  }

  /// <summary>Field number for the "metrics" field.</summary>
  public const int MetricsFieldNumber = 3;
  private static readonly pbc::MapField<string, string>.Codec _map_metrics_codec
      = new pbc::MapField<string, string>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForString(18), 26);
  private readonly pbc::MapField<string, string> metrics_ = new pbc::MapField<string, string>();
  /// <summary>
  /// A set of engine specific values that can be reported, for instance
  /// - "grounding-time": "10ms"
  /// - "expanded-states": "1290"
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::MapField<string, string> Metrics
  {
    get { return metrics_; }
  }

  /// <summary>Field number for the "log_messages" field.</summary>
  public const int LogMessagesFieldNumber = 4;
  private static readonly pb::FieldCodec<global::LogMessage> _repeated_logMessages_codec
      = pb::FieldCodec.ForMessage(34, global::LogMessage.Parser);
  private readonly pbc::RepeatedField<global::LogMessage> logMessages_ = new pbc::RepeatedField<global::LogMessage>();
  /// <summary>
  /// Optional log messages about the engine's activity.
  /// Note that it should not be expected that logging messages are visible to the end user.
  /// If used in conjunction with INTERNAL_ERROR or UNSUPPORTED_PROBLEM, it would be expected to have at least one log message at the ERROR level.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::LogMessage> LogMessages
  {
    get { return logMessages_; }
  }

  /// <summary>Field number for the "engine" field.</summary>
  public const int EngineFieldNumber = 5;
  private global::Engine engine_;
  /// <summary>
  /// Synthetic description of the engine that generated this message.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Engine Engine
  {
    get { return engine_; }
    set
    {
      engine_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as PlanGenerationResult);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(PlanGenerationResult other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Status != other.Status) return false;
    if (!object.Equals(Plan, other.Plan)) return false;
    if (!Metrics.Equals(other.Metrics)) return false;
    if (!logMessages_.Equals(other.logMessages_)) return false;
    if (!object.Equals(Engine, other.Engine)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Status != 0) hash ^= Status.GetHashCode();
    if (plan_ != null) hash ^= Plan.GetHashCode();
    hash ^= Metrics.GetHashCode();
    hash ^= logMessages_.GetHashCode();
    if (engine_ != null) hash ^= Engine.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Status != 0)
    {
      output.WriteRawTag(8);
      output.WriteEnum((int)Status);
    }
    if (plan_ != null)
    {
      output.WriteRawTag(18);
      output.WriteMessage(Plan);
    }
    metrics_.WriteTo(output, _map_metrics_codec);
    logMessages_.WriteTo(output, _repeated_logMessages_codec);
    if (engine_ != null)
    {
      output.WriteRawTag(42);
      output.WriteMessage(Engine);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Status != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Status);
    }
    if (plan_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Plan);
    }
    size += metrics_.CalculateSize(_map_metrics_codec);
    size += logMessages_.CalculateSize(_repeated_logMessages_codec);
    if (engine_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Engine);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(PlanGenerationResult other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Status != 0)
    {
      Status = other.Status;
    }
    if (other.plan_ != null)
    {
      if (plan_ == null)
      {
        plan_ = new global::Plan();
      }
      Plan.MergeFrom(other.Plan);
    }
    metrics_.Add(other.metrics_);
    logMessages_.Add(other.logMessages_);
    if (other.engine_ != null)
    {
      if (engine_ == null)
      {
        engine_ = new global::Engine();
      }
      Engine.MergeFrom(other.Engine);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            status_ = (global::PlanGenerationResult.Types.Status)input.ReadEnum();
            break;
          }
        case 18:
          {
            if (plan_ == null)
            {
              plan_ = new global::Plan();
            }
            input.ReadMessage(plan_);
            break;
          }
        case 26:
          {
            metrics_.AddEntriesFrom(input, _map_metrics_codec);
            break;
          }
        case 34:
          {
            logMessages_.AddEntriesFrom(input, _repeated_logMessages_codec);
            break;
          }
        case 42:
          {
            if (engine_ == null)
            {
              engine_ = new global::Engine();
            }
            input.ReadMessage(engine_);
            break;
          }
      }
    }
  }

  #region Nested types
  /// <summary>Container for nested types declared in the PlanGenerationResult message type.</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static partial class Types
  {
    /// <summary>
    /// ==== Engine stopped normally ======
    /// </summary>
    public enum Status
    {
      /// <summary>
      /// Valid plan found
      /// The `plan` field must be set.
      /// </summary>
      [pbr::OriginalName("SOLVED_SATISFICING")] SolvedSatisficing = 0,
      /// <summary>
      /// Plan found with optimality guarantee
      /// The `plan` field must be set and contains an optimal solution.
      /// </summary>
      [pbr::OriginalName("SOLVED_OPTIMALLY")] SolvedOptimally = 1,
      /// <summary>
      /// No plan exists
      /// </summary>
      [pbr::OriginalName("UNSOLVABLE_PROVEN")] UnsolvableProven = 2,
      /// <summary>
      /// The engine was not able to find a solution but does not give any guarantee that none exist
      /// (i.e. the engine might not be complete)
      /// </summary>
      [pbr::OriginalName("UNSOLVABLE_INCOMPLETELY")] UnsolvableIncompletely = 3,
      /// <summary>
      /// The engine ran out of time
      /// </summary>
      [pbr::OriginalName("TIMEOUT")] Timeout = 13,
      /// <summary>
      /// The engine ran out of memory
      /// </summary>
      [pbr::OriginalName("MEMOUT")] Memout = 14,
      /// <summary>
      /// The engine faced an internal error.
      /// </summary>
      [pbr::OriginalName("INTERNAL_ERROR")] InternalError = 15,
      /// <summary>
      /// The problem submitted is not supported by the engine.
      /// </summary>
      [pbr::OriginalName("UNSUPPORTED_PROBLEM")] UnsupportedProblem = 16,
      /// <summary>
      /// ====== Intermediate answer ======
      /// This Answer is an Intermediate Answer and not a Final one
      /// </summary>
      [pbr::OriginalName("INTERMEDIATE")] Intermediate = 17,
    }

  }
  #endregion

}

public sealed partial class Engine : pb::IMessage<Engine>
{
  private static readonly pb::MessageParser<Engine> _parser = new pb::MessageParser<Engine>(() => new Engine());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<Engine> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[39]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Engine()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Engine(Engine other) : this()
  {
    name_ = other.name_;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public Engine Clone()
  {
    return new Engine(this);
  }

  /// <summary>Field number for the "name" field.</summary>
  public const int NameFieldNumber = 1;
  private string name_ = "";
  /// <summary>
  /// Short name of the engine (planner, validator, ...)
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public string Name
  {
    get { return name_; }
    set
    {
      name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as Engine);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(Engine other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Name != other.Name) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Name.Length != 0) hash ^= Name.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Name.Length != 0)
    {
      output.WriteRawTag(10);
      output.WriteString(Name);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Name.Length != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(Engine other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Name.Length != 0)
    {
      Name = other.Name;
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            Name = input.ReadString();
            break;
          }
      }
    }
  }

}

/// <summary>
/// Message sent by the validator.
/// </summary>
public sealed partial class ValidationResult : pb::IMessage<ValidationResult>
{
  private static readonly pb::MessageParser<ValidationResult> _parser = new pb::MessageParser<ValidationResult>(() => new ValidationResult());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<ValidationResult> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[40]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ValidationResult()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ValidationResult(ValidationResult other) : this()
  {
    status_ = other.status_;
    logMessages_ = other.logMessages_.Clone();
    engine_ = other.engine_ != null ? other.engine_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public ValidationResult Clone()
  {
    return new ValidationResult(this);
  }

  /// <summary>Field number for the "status" field.</summary>
  public const int StatusFieldNumber = 1;
  private global::ValidationResult.Types.ValidationResultStatus status_ = 0;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::ValidationResult.Types.ValidationResultStatus Status
  {
    get { return status_; }
    set
    {
      status_ = value;
    }
  }

  /// <summary>Field number for the "log_messages" field.</summary>
  public const int LogMessagesFieldNumber = 2;
  private static readonly pb::FieldCodec<global::LogMessage> _repeated_logMessages_codec
      = pb::FieldCodec.ForMessage(18, global::LogMessage.Parser);
  private readonly pbc::RepeatedField<global::LogMessage> logMessages_ = new pbc::RepeatedField<global::LogMessage>();
  /// <summary>
  /// Optional. Information given by the engine to the user.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::LogMessage> LogMessages
  {
    get { return logMessages_; }
  }

  /// <summary>Field number for the "engine" field.</summary>
  public const int EngineFieldNumber = 3;
  private global::Engine engine_;
  /// <summary>
  /// Synthetic description of the engine that generated this message.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Engine Engine
  {
    get { return engine_; }
    set
    {
      engine_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as ValidationResult);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(ValidationResult other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (Status != other.Status) return false;
    if (!logMessages_.Equals(other.logMessages_)) return false;
    if (!object.Equals(Engine, other.Engine)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (Status != 0) hash ^= Status.GetHashCode();
    hash ^= logMessages_.GetHashCode();
    if (engine_ != null) hash ^= Engine.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (Status != 0)
    {
      output.WriteRawTag(8);
      output.WriteEnum((int)Status);
    }
    logMessages_.WriteTo(output, _repeated_logMessages_codec);
    if (engine_ != null)
    {
      output.WriteRawTag(26);
      output.WriteMessage(Engine);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (Status != 0)
    {
      size += 1 + pb::CodedOutputStream.ComputeEnumSize((int)Status);
    }
    size += logMessages_.CalculateSize(_repeated_logMessages_codec);
    if (engine_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Engine);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(ValidationResult other)
  {
    if (other == null)
    {
      return;
    }
    if (other.Status != 0)
    {
      Status = other.Status;
    }
    logMessages_.Add(other.logMessages_);
    if (other.engine_ != null)
    {
      if (engine_ == null)
      {
        engine_ = new global::Engine();
      }
      Engine.MergeFrom(other.Engine);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 8:
          {
            status_ = (global::ValidationResult.Types.ValidationResultStatus)input.ReadEnum();
            break;
          }
        case 18:
          {
            logMessages_.AddEntriesFrom(input, _repeated_logMessages_codec);
            break;
          }
        case 26:
          {
            if (engine_ == null)
            {
              engine_ = new global::Engine();
            }
            input.ReadMessage(engine_);
            break;
          }
      }
    }
  }

  #region Nested types
  /// <summary>Container for nested types declared in the ValidationResult message type.</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static partial class Types
  {
    public enum ValidationResultStatus
    {
      /// <summary>
      /// The Plan is valid for the Problem.
      /// </summary>
      [pbr::OriginalName("VALID")] Valid = 0,
      /// <summary>
      /// The Plan is not valid for the Problem.
      /// </summary>
      [pbr::OriginalName("INVALID")] Invalid = 1,
      /// <summary>
      /// The engine can't determine if the plan is VALID or INVALID for the Problem.
      /// </summary>
      [pbr::OriginalName("UNKNOWN")] Unknown = 2,
    }

  }
  #endregion

}

/// <summary>
/// Message sent by the grounder.
/// </summary>
public sealed partial class CompilerResult : pb::IMessage<CompilerResult>
{
  private static readonly pb::MessageParser<CompilerResult> _parser = new pb::MessageParser<CompilerResult>(() => new CompilerResult());
  private pb::UnknownFieldSet _unknownFields;
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pb::MessageParser<CompilerResult> Parser { get { return _parser; } }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public static pbr::MessageDescriptor Descriptor
  {
    get { return global::UnifiedPlanningReflection.Descriptor.MessageTypes[41]; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  pbr::MessageDescriptor pb::IMessage.Descriptor
  {
    get { return Descriptor; }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public CompilerResult()
  {
    OnConstruction();
  }

  partial void OnConstruction();

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public CompilerResult(CompilerResult other) : this()
  {
    problem_ = other.problem_ != null ? other.problem_.Clone() : null;
    mapBackPlan_ = other.mapBackPlan_.Clone();
    logMessages_ = other.logMessages_.Clone();
    engine_ = other.engine_ != null ? other.engine_.Clone() : null;
    _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public CompilerResult Clone()
  {
    return new CompilerResult(this);
  }

  /// <summary>Field number for the "problem" field.</summary>
  public const int ProblemFieldNumber = 1;
  private global::Problem problem_;
  /// <summary>
  /// The problem generated by the Compiler
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Problem Problem
  {
    get { return problem_; }
    set
    {
      problem_ = value;
    }
  }

  /// <summary>Field number for the "map_back_plan" field.</summary>
  public const int MapBackPlanFieldNumber = 2;
  private static readonly pbc::MapField<string, global::ActionInstance>.Codec _map_mapBackPlan_codec
      = new pbc::MapField<string, global::ActionInstance>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::ActionInstance.Parser), 18);
  private readonly pbc::MapField<string, global::ActionInstance> mapBackPlan_ = new pbc::MapField<string, global::ActionInstance>();
  /// <summary>
  /// The map_back_plan field is a map from the ActionInstance of the
  /// compiled problem to the original ActionInstance.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::MapField<string, global::ActionInstance> MapBackPlan
  {
    get { return mapBackPlan_; }
  }

  /// <summary>Field number for the "log_messages" field.</summary>
  public const int LogMessagesFieldNumber = 3;
  private static readonly pb::FieldCodec<global::LogMessage> _repeated_logMessages_codec
      = pb::FieldCodec.ForMessage(26, global::LogMessage.Parser);
  private readonly pbc::RepeatedField<global::LogMessage> logMessages_ = new pbc::RepeatedField<global::LogMessage>();
  /// <summary>
  /// Optional. Information given by the engine to the user.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public pbc::RepeatedField<global::LogMessage> LogMessages
  {
    get { return logMessages_; }
  }

  /// <summary>Field number for the "engine" field.</summary>
  public const int EngineFieldNumber = 4;
  private global::Engine engine_;
  /// <summary>
  /// Synthetic description of the engine that generated this message.
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public global::Engine Engine
  {
    get { return engine_; }
    set
    {
      engine_ = value;
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override bool Equals(object other)
  {
    return Equals(other as CompilerResult);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public bool Equals(CompilerResult other)
  {
    if (ReferenceEquals(other, null))
    {
      return false;
    }
    if (ReferenceEquals(other, this))
    {
      return true;
    }
    if (!object.Equals(Problem, other.Problem)) return false;
    if (!MapBackPlan.Equals(other.MapBackPlan)) return false;
    if (!logMessages_.Equals(other.logMessages_)) return false;
    if (!object.Equals(Engine, other.Engine)) return false;
    return Equals(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override int GetHashCode()
  {
    int hash = 1;
    if (problem_ != null) hash ^= Problem.GetHashCode();
    hash ^= MapBackPlan.GetHashCode();
    hash ^= logMessages_.GetHashCode();
    if (engine_ != null) hash ^= Engine.GetHashCode();
    if (_unknownFields != null)
    {
      hash ^= _unknownFields.GetHashCode();
    }
    return hash;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public override string ToString()
  {
    return pb::JsonFormatter.ToDiagnosticString(this);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void WriteTo(pb::CodedOutputStream output)
  {
    if (problem_ != null)
    {
      output.WriteRawTag(10);
      output.WriteMessage(Problem);
    }
    mapBackPlan_.WriteTo(output, _map_mapBackPlan_codec);
    logMessages_.WriteTo(output, _repeated_logMessages_codec);
    if (engine_ != null)
    {
      output.WriteRawTag(34);
      output.WriteMessage(Engine);
    }
    if (_unknownFields != null)
    {
      _unknownFields.WriteTo(output);
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public int CalculateSize()
  {
    int size = 0;
    if (problem_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Problem);
    }
    size += mapBackPlan_.CalculateSize(_map_mapBackPlan_codec);
    size += logMessages_.CalculateSize(_repeated_logMessages_codec);
    if (engine_ != null)
    {
      size += 1 + pb::CodedOutputStream.ComputeMessageSize(Engine);
    }
    if (_unknownFields != null)
    {
      size += _unknownFields.CalculateSize();
    }
    return size;
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(CompilerResult other)
  {
    if (other == null)
    {
      return;
    }
    if (other.problem_ != null)
    {
      if (problem_ == null)
      {
        problem_ = new global::Problem();
      }
      Problem.MergeFrom(other.Problem);
    }
    mapBackPlan_.Add(other.mapBackPlan_);
    logMessages_.Add(other.logMessages_);
    if (other.engine_ != null)
    {
      if (engine_ == null)
      {
        engine_ = new global::Engine();
      }
      Engine.MergeFrom(other.Engine);
    }
    _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
  public void MergeFrom(pb::CodedInputStream input)
  {
    uint tag;
    while ((tag = input.ReadTag()) != 0)
    {
      switch (tag)
      {
        default:
          _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
          break;
        case 10:
          {
            if (problem_ == null)
            {
              problem_ = new global::Problem();
            }
            input.ReadMessage(problem_);
            break;
          }
        case 18:
          {
            mapBackPlan_.AddEntriesFrom(input, _map_mapBackPlan_codec);
            break;
          }
        case 26:
          {
            logMessages_.AddEntriesFrom(input, _repeated_logMessages_codec);
            break;
          }
        case 34:
          {
            if (engine_ == null)
            {
              engine_ = new global::Engine();
            }
            input.ReadMessage(engine_);
            break;
          }
      }
    }
  }

}

#endregion


#endregion Designer generated code